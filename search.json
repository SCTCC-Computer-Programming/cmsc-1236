[
  {
    "objectID": "weekly-overview/week-03/index.html",
    "href": "weekly-overview/week-03/index.html",
    "title": "Week 3 Guide",
    "section": "",
    "text": "This week is a refresher of Python’s built-in types. You already know how to make lists and dictionaries and loop over them. Chapters 8–9 extend that foundation by showing how to predict what happens when the same object is reused, when a type is mutated in place, and when data structures are nested.\nIn the Week 3 demo, the examples are designed to help you predict the behavior of Python’s built-in types. You will practice tracing what an operation does to an object (creates a new object vs changes an existing one), and you will learn how to explain the output you see in terms of identity, equality, and mutation."
  },
  {
    "objectID": "weekly-overview/week-03/index.html#chapters-89-concepts",
    "href": "weekly-overview/week-03/index.html#chapters-89-concepts",
    "title": "Week 3 Guide",
    "section": "Chapters 8–9 concepts",
    "text": "Chapters 8–9 concepts\n\nNames, objects, and references\nChapters 8–9 review Python’s object model: variables are names that refer to objects, and collection objects store references to other objects rather than copying them. This explains why two names can refer to the same object, and why an in-place change can appear in more than one place.\nThe demo examples show:\n\nidentity vs equality (is vs ==)\nhow aliasing can occur through assignment\nhow mutation differs from rebinding for mutable objects\n\n\n\nSequence types (lists and tuples)\nChapter 8 presents lists and tuples as sequence types. Lists support in-place change, while tuples do not. These differences matter most when programs reuse values, build nested structures, or attempt to modify sequence items.\nThe demo examples show:\n\nlists as mutable sequences (operations that change an existing list)\ntuples as immutable sequences (item assignment fails)\nslice assignment as an in-place list operation\ncorrect and incorrect ways to construct nested lists\n\n\n\nMapping type (dictionaries)\nDictionaries are the built-in mapping type: values are stored and retrieved by key rather than by position. Chapter 8 covers dictionary creation and core operations used in real programs.\nThe demo examples show:\n\ninsertion order during iteration (order of insertion, not sorting)\nsafe access when a key may not exist (in, get)\ncontrolled updates using copy and update\ncomparing dictionaries by comparing their key collections\n\n\n\nSet types\nSets represent an unordered collection of unique values. Chapter 8 introduces sets and the operations used to test membership and reason about distinct values.\nThe demo examples show:\n\nconstructing sets to remove duplicates\nmembership testing with in\nthe hashability requirement for set elements (and why mutable types like lists cannot be elements)\n\n\n\nCopying nested structures (shallow vs deep)\nWhen a structure is nested (for example, a list of lists), “copy” can mean copying only the outer container or copying both outer and inner objects. Chapter 9 introduces this distinction and why it matters for program correctness.\nThe demo examples show:\n\nshallow copy: new outer object with shared inner objects\ndeep copy: new outer object with copied inner objects\n\n\n\nCourse tool note: file access with pathlib.Path\nThe textbook uses open() as the standard and universal file interface. This week’s demo also introduces pathlib.Path, a modern alternative that is common in current Python code. pathlib is not covered in CMSC 1203 and it is not part of Chapters 8–9, but it builds directly on the same file concepts and simplifies common read/write tasks."
  },
  {
    "objectID": "weekly-overview/week-03/index.html#reading-expectations-for-week-3-quiz-preparation",
    "href": "weekly-overview/week-03/index.html#reading-expectations-for-week-3-quiz-preparation",
    "title": "Week 3 Guide",
    "section": "Reading expectations for Week 3 (quiz preparation)",
    "text": "Reading expectations for Week 3 (quiz preparation)\nAs you read Chapters 8–9 and run the demo, check whether you can answer the following in your own words:\n\nWhat is the difference between identity and equality (is vs ==)?\nHow can two different lists be equal but not be the same object?\nWhat is the difference between rebinding a name and mutating a list in place?\nWhy can list repetition with * produce surprising results for nested lists?\nWhat does slice assignment do to a list object?\nWhat does “insertion order” mean for dictionaries, and what does it not mean?\nWhen should you use get instead of direct indexing (d[key])?\nWhy do set elements have to be hashable, and what kinds of objects are not hashable?\nWhat is the difference between a shallow copy and a deep copy of a nested list?\nWhat does Path.write_text() do if the file does not exist yet, and where is that file created?"
  },
  {
    "objectID": "weekly-overview/week-03/index.html#week-3-tasks",
    "href": "weekly-overview/week-03/index.html#week-3-tasks",
    "title": "Week 3 Guide",
    "section": "Week 3 tasks",
    "text": "Week 3 tasks\n\nWatch the Week 3 demo walkthrough in your CMSC 1236 YouTube playlist.\n\nHere is the link to the Week 3 examples.\nDownload Jupyter Notebook\n\nRead Learning Python 6e, Chapters 8–9 (complete).\nComplete the Week 3 D2L quiz (Chapter 8–9 concepts + demo examples)."
  },
  {
    "objectID": "weekly-overview/week-03/index.html#knowledge-goals-for-week-3",
    "href": "weekly-overview/week-03/index.html#knowledge-goals-for-week-3",
    "title": "Week 3 Guide",
    "section": "Knowledge goals for Week 3",
    "text": "Knowledge goals for Week 3\nBy the end of the week, you should be able to:\n\ninterpret and explain short code outputs involving Python’s built-in types from Chapters 8–9\ndetermine whether an operation creates a new object or mutates an existing object, and explain how that affects other names\nreason correctly about nested structures, copying, and when inner objects are shared\napply core operations for sequences, mappings, and sets to solve small problems and explain your choices\nuse pathlib.Path to write and read a text file in a notebook and describe where the file is created (the working directory)"
  },
  {
    "objectID": "weekly-overview/week-01/index.html",
    "href": "weekly-overview/week-01/index.html",
    "title": "Week 1 Guide",
    "section": "",
    "text": "The focus of Week 1 is to establish your course development environment and confirm that you can run, test, and manage Python programs using the standard workflow for this course. You will also begin the first project (Virtual Pet v1) by building the menu loop skeleton and practicing basic input/output patterns.\nWeek 1 is a preparation week. There is no graded submission this week, but the work you complete here is required to be successful in Week 2.",
    "crumbs": [
      "Home",
      "Weekly Overview",
      "Week 1"
    ]
  },
  {
    "objectID": "weekly-overview/week-01/index.html#week-1-focus",
    "href": "weekly-overview/week-01/index.html#week-1-focus",
    "title": "Week 1 Guide",
    "section": "",
    "text": "The focus of Week 1 is to establish your course development environment and confirm that you can run, test, and manage Python programs using the standard workflow for this course. You will also begin the first project (Virtual Pet v1) by building the menu loop skeleton and practicing basic input/output patterns.\nWeek 1 is a preparation week. There is no graded submission this week, but the work you complete here is required to be successful in Week 2.",
    "crumbs": [
      "Home",
      "Weekly Overview",
      "Week 1"
    ]
  },
  {
    "objectID": "weekly-overview/week-01/index.html#course-workflow-expectations",
    "href": "weekly-overview/week-01/index.html#course-workflow-expectations",
    "title": "Week 1 Guide",
    "section": "Course workflow expectations",
    "text": "Course workflow expectations\nIn this course, you will primarily work in a file-and-terminal workflow:\n\nYou will write Python in .py files (notebooks are not the default workspace for this course).\nYou will run programs from the terminal (and/or the VS Code run tools that invoke the same interpreter).\nYou will use a project virtual environment to keep Python settings consistent.\nYou will use Git to track changes and document progress.\n\nBefore you begin project work, verify that VS Code is using the Python interpreter from your project virtual environment. If you use the wrong interpreter, you may see behavior that does not match your intended setup.",
    "crumbs": [
      "Home",
      "Weekly Overview",
      "Week 1"
    ]
  },
  {
    "objectID": "weekly-overview/week-01/index.html#core-tools-we-will-be-using",
    "href": "weekly-overview/week-01/index.html#core-tools-we-will-be-using",
    "title": "Week 1 Guide",
    "section": "Core tools we will be using",
    "text": "Core tools we will be using\n\n\n\n\n\n\n\n\nTool\nWhat it is used for in this course\nWhen you will notice it\n\n\n\n\nPython 3\nWriting and running programs using the standard library and core language features\nEvery week\n\n\nVS Code\nEditing, running, and debugging Python programs\nEvery week\n\n\nTerminal (Command Line)\nRunning programs, navigating folders, and using Git\nEvery week\n\n\nvenv\nCreating an isolated Python environment per project\nThroughout the semester\n\n\nGit\nTracking work history and managing incremental changes\nThroughout the semester",
    "crumbs": [
      "Home",
      "Weekly Overview",
      "Week 1"
    ]
  },
  {
    "objectID": "weekly-overview/week-01/index.html#week-1-project-work-virtual-pet-v1-kickoff",
    "href": "weekly-overview/week-01/index.html#week-1-project-work-virtual-pet-v1-kickoff",
    "title": "Week 1 Guide",
    "section": "Week 1 project work: Virtual Pet v1 kickoff",
    "text": "Week 1 project work: Virtual Pet v1 kickoff\nVirtual Pet v1 is introduced in Week 1 and developed further in Week 2. In Week 1, the goal is to build the foundation of a menu-driven command-line program:\n\na clear, repeatable menu display\na loop that continues until the user chooses to quit\nmenu options that execute distinct code paths\nbasic program state tracked in variables (Week 2 will extend and improve the design)\n\nYour Week 1 implementation should include input validation for the menu choice (type and range). This prevents common input mistakes from terminating the program.",
    "crumbs": [
      "Home",
      "Weekly Overview",
      "Week 1"
    ]
  },
  {
    "objectID": "weekly-overview/week-01/index.html#reading-for-week-1-learning-python-6th-edition",
    "href": "weekly-overview/week-01/index.html#reading-for-week-1-learning-python-6th-edition",
    "title": "Week 1 Guide",
    "section": "Reading for Week 1 (Learning Python, 6th Edition)",
    "text": "Reading for Week 1 (Learning Python, 6th Edition)\nRead Chapters 1–7. This reading is intended as review and reference for the language features you will use immediately: expressions, basic types, control flow, loops, and program structure.",
    "crumbs": [
      "Home",
      "Weekly Overview",
      "Week 1"
    ]
  },
  {
    "objectID": "weekly-overview/week-01/index.html#week-1-tasks",
    "href": "weekly-overview/week-01/index.html#week-1-tasks",
    "title": "Week 1 Guide",
    "section": "Week 1 tasks",
    "text": "Week 1 tasks\nComplete the following tasks during Week 1:\n\nEnvironment setup\n\nCreate your course/project folder structure.\nCreate a virtual environment for your project.\nConfigure VS Code to use the project venv interpreter.\nConfirm you can run a .py file from the terminal.\n\nGit workflow\n\nInitialize a Git repository for your work. (You can choose how to manage the repository)\n\nVirtual Pet v1 kickoff\n\nCreate the menu loop skeleton.\nImplement several menu actions (simple behavior is acceptable at this stage).\nAdd menu input validation so the program continues running when input is invalid.\n\nReading\n\nLearning Python 6e Chapters 1–7. (Review)",
    "crumbs": [
      "Home",
      "Weekly Overview",
      "Week 1"
    ]
  },
  {
    "objectID": "weekly-overview/week-01/index.html#knowledge-goals-for-week-1",
    "href": "weekly-overview/week-01/index.html#knowledge-goals-for-week-1",
    "title": "Week 1 Guide",
    "section": "Knowledge goals for Week 1",
    "text": "Knowledge goals for Week 1\nBy the end of Week 1, you should be able to:\n\ndescribe what a virtual environment is and why the course uses it\nselect and verify the correct Python interpreter in VS Code\nrun a Python script from the terminal and interpret basic error messages\nuse Git to track work at a basic level (status, add, commit)\nimplement a menu-driven loop with input validation using while, if/elif/else, and input()",
    "crumbs": [
      "Home",
      "Weekly Overview",
      "Week 1"
    ]
  },
  {
    "objectID": "shared/policies/homework-coursework.html",
    "href": "shared/policies/homework-coursework.html",
    "title": "Homework / Coursework policies",
    "section": "",
    "text": "Due dates and late work\n\nAll assignments must be submitted by the due date/time in D2L.\nLate work is not accepted. (“Late” = not in the dropbox by the due/end date.)\nSome assignments have multiple required components (video + file); missing any required component makes the assignment ineligible for grading.\nVideo work must be accessible at grading time or it is not accepted.\nStudents should archive/keep their submitted work.\nGroup work (if assigned) is not eligible for makeup.\n\n\n\nSubmission standards\n\nAssignment-specific submission standards will be provided in instructions.\nWork may be rejected or heavily penalized for not following standards, including:\n\nincorrect file format\nincorrect file naming\nnot following submission instructions\n\nStudents should contact the instructor before the due date with submission questions.\nAssignments will not be accepted via email.\n\n\n\nTests / quizzes (D2L)\n\nQuizzes/tests may be scheduled or unannounced; must be completed by the due date.\nPassword-protected test passwords may not be shared (integrity violation).\nMultiple attempts may be allowed, with thresholds:\n\nmust score &gt;60% on attempt 1 to unlock attempt 2\nmust score &gt;80% on attempt 2 to unlock attempt 3 (if offered)\n\nTime limits apply; exceeding the time limit may result in a 0 and block further work.\nStudents may not leave a quiz once started.\nAuto-generated quizzes may prevent backtracking; students are responsible for careful navigation/submission.\nNo make-up tests/quizzes.\n\n\n\nGrading practices (coursework-related)\n\nGrades are posted in D2L; students are responsible for verifying accuracy.\nSome activities may be assigned but not graded (self-review practice).\nRubrics are used for most activities; some items are auto-graded.\n“Proof” files may be provided; students are expected to review feedback/proof files.\nNo extra credit / no additional assignments offered.\nSome assignments may be pass/fail.\n\n\n\nVideo related coursework expectations\n\nSome assignments require webcam-based video submission (and possibly desktop recording).\nStudent must be visable in any video assignment or the assignment will not be graded.\nStudent must introduce themselves by name, assignment, and course at the start of any video submission - “Hello my name is [name], this is the [assignment] for [class]”\nStudents must dress appropriately/considerately for online video assignments.",
    "crumbs": [
      "Home",
      "Course information",
      "Assignment Policies"
    ]
  },
  {
    "objectID": "shared/policies/ai-policy.html",
    "href": "shared/policies/ai-policy.html",
    "title": "Using AI as a Learning Tool",
    "section": "",
    "text": "Purpose of this policy\nTools that use artificial intelligence are now widely available, and many of you already use them when learning technical material. This course allows the use of AI tools as a learning aid, similar to a tutor or reference source. At the same time, this course requires that submitted work reflect your own understanding and decision-making.\nThis page explains how AI tools may be used productively in this course, and where their use becomes inappropriate.\n\n\nAI as a learning tool\nUsing AI as a learning tool means using it to clarify ideas, terminology, or examples that you do not yet understand.\n\nIdeas An idea is a concept or principle discussed in the course materials, such as how a process works, why a particular approach is used, or what a tool is designed to do. Clarifying an idea means using AI to help you understand the purpose or reasoning behind something you have already encountered in class, rather than asking for a final answer.\nTerminology Terminology refers to the specific words and phrases used in technical subjects. These terms often have precise meanings that differ from everyday usage. Using AI appropriately includes asking for explanations of unfamiliar terms so you can understand how they are used in context, especially when reading textbooks, documentation, or assignment instructions.\nExamples Examples are demonstrations that show how an idea or concept is applied in practice. Using AI to clarify examples means asking for help understanding why an example works, what each part is doing, or how it relates to the underlying concept. It does not mean copying an example and submitting it as your own work.\n\nIn all cases, using AI as a learning tool should help you build understanding, not replace the effort of reading, experimenting, or reasoning through a problem yourself.\n\n\nAI as a crutch\nAI tools can support learning, but they can also be used in ways that reduce learning. This policy uses the term “crutch” to describe situations where the tool is doing the thinking and decision-making that the student is expected to practice.\nUsing AI as a crutch means relying on it to produce work or reasoning that you do not understand well enough to explain and defend. The issue is not that the tool was used; the issue is that the tool replaced the learning process.\nInappropriate uses include:\n\nAsking AI to complete an assignment or lab task for you Example: “Write the solution for this assignment.”\nSubmitting AI-generated code, answers, or explanations that you cannot explain in your own words Example: Copying an explanation of why a solution works without being able to describe the steps yourself.\nTreating AI output as authoritative without verification Example: Accepting an answer that conflicts with course materials, documentation, or results you can reproduce.\nUsing AI to bypass the learning objective Example: Asking for the final answer when the point of the activity is to practice reasoning, debugging, designing, or interpreting results.\nUsing AI to write or script reflections that are meant to describe your own understanding Example: Asking AI to generate a script or talking points for a reflection video instead of explaining the ideas in your own words.\n\nIn these cases, AI is being used to avoid the intended learning work rather than to support it.\n\n\nWhy this matters\nAI can produce output that appears correct even when it contains errors or is based on incorrect assumptions. Because of that, it is important to treat AI output as a starting point for learning, not as an authority.\nThis course emphasizes:\n\nverifying results,\nunderstanding workflows,\nand explaining decisions clearly.\n\nIf you rely on AI answers without testing them or understanding them, you are likely to miss errors and build misunderstandings. Those gaps tend to surface later in the course when tasks require independent problem solving, accurate interpretation, and clear explanations in graded work.\n\n\nExpectations for submitted work\nAll submitted work must reflect your own understanding.\nThis means:\n\nYou should be able to explain any code you submit.\nYou should be able to describe why you made particular choices (model, metric, preprocessing).\nIn reflections, your explanations should sound like you, not like a generic answer generator.\n\nYou are not required to disclose routine AI use for clarification or studying. However, if your work suggests that you do not understand what you submitted, that will be treated the same way as any other lack of understanding, regardless of the source.\nIf you use an AI tool, ask yourself:\n\nCould I explain this answer to another student without looking it up?\nDid I test or verify what the tool suggested?\nDid the tool help me understand, or did it just give me something to submit?\n\nIf the tool helped you understand, you are using it appropriately. If it replaced your thinking, you are not.",
    "crumbs": [
      "Home",
      "Course information",
      "AI Policy"
    ]
  },
  {
    "objectID": "shared/guides/setup/jupyter-learning-links.html",
    "href": "shared/guides/setup/jupyter-learning-links.html",
    "title": "Jupyter Notebooks & JupyterLab Learning Resources",
    "section": "",
    "text": "Jupyter Notebook Tutorial: Introduction, Setup, and Walkthrough\nby Corey Schafer (2016, ~30 min) — Comprehensive beginner overview of installation, navigation, cells, kernels, and Markdown.\n\nJupyter Notebooks Tutorial | How to use them & tips and tricks!\nby AssemblyAI (2022, ~18 min) — Practical guide to common settings, basic operations, cell management, indicators, keyboard shortcuts, and useful tips for data science workflows.\n\nJupyter Notebook Complete Beginner Guide - From Jupyter to JupyterLab, Google Colab and Kaggle!\nby Rob Mulla (2022, ~25 min) — Covers classic Notebooks, transition to JupyterLab, and cloud-based alternatives.\n\nGetting Started with Jupyter Notebooks in VS Code\nby Visual Studio Code (2024, ~6 min) — Official guide to creating, running, and debugging Jupyter Notebooks directly in VS Code, including environment setup, code execution, Markdown support, variable exploration, and data visualization."
  },
  {
    "objectID": "shared/guides/setup/jupyter-learning-links.html#introduction-to-jupyter-notebooks",
    "href": "shared/guides/setup/jupyter-learning-links.html#introduction-to-jupyter-notebooks",
    "title": "Jupyter Notebooks & JupyterLab Learning Resources",
    "section": "",
    "text": "Jupyter Notebook Tutorial: Introduction, Setup, and Walkthrough\nby Corey Schafer (2016, ~30 min) — Comprehensive beginner overview of installation, navigation, cells, kernels, and Markdown.\n\nJupyter Notebooks Tutorial | How to use them & tips and tricks!\nby AssemblyAI (2022, ~18 min) — Practical guide to common settings, basic operations, cell management, indicators, keyboard shortcuts, and useful tips for data science workflows.\n\nJupyter Notebook Complete Beginner Guide - From Jupyter to JupyterLab, Google Colab and Kaggle!\nby Rob Mulla (2022, ~25 min) — Covers classic Notebooks, transition to JupyterLab, and cloud-based alternatives.\n\nGetting Started with Jupyter Notebooks in VS Code\nby Visual Studio Code (2024, ~6 min) — Official guide to creating, running, and debugging Jupyter Notebooks directly in VS Code, including environment setup, code execution, Markdown support, variable exploration, and data visualization."
  },
  {
    "objectID": "shared/guides/setup/jupyter-learning-links.html#recent-developments-in-the-jupyter-ecosystem",
    "href": "shared/guides/setup/jupyter-learning-links.html#recent-developments-in-the-jupyter-ecosystem",
    "title": "Jupyter Notebooks & JupyterLab Learning Resources",
    "section": "Recent Developments in the Jupyter Ecosystem",
    "text": "Recent Developments in the Jupyter Ecosystem\nJupyter Frontends & JupyterLite updates | Jupyter Open Studio Day 2025\n(2025, ~30 min) — Overview of current features and updates from the official Jupyter community.\n\nAdditional resources and interactive examples are available on the official Jupyter website."
  },
  {
    "objectID": "shared/guides/cmsc-2208/week-02/cmsc-2208-chap-02-learning-resources.html",
    "href": "shared/guides/cmsc-2208/week-02/cmsc-2208-chap-02-learning-resources.html",
    "title": "Week 2: Chapter 2 Learning Videos (Supervised Learning + kNN)",
    "section": "",
    "text": "These are optional “extra help” videos for Week 2.\nWatch them when the reading feels abstract or when you want a second explanation of the same concept."
  },
  {
    "objectID": "shared/guides/cmsc-2208/week-02/cmsc-2208-chap-02-learning-resources.html#how-to-use-these-videos",
    "href": "shared/guides/cmsc-2208/week-02/cmsc-2208-chap-02-learning-resources.html#how-to-use-these-videos",
    "title": "Week 2: Chapter 2 Learning Videos (Supervised Learning + kNN)",
    "section": "",
    "text": "These are optional “extra help” videos for Week 2.\nWatch them when the reading feels abstract or when you want a second explanation of the same concept."
  },
  {
    "objectID": "shared/guides/cmsc-2208/week-02/cmsc-2208-chap-02-learning-resources.html#classification-vs-regression",
    "href": "shared/guides/cmsc-2208/week-02/cmsc-2208-chap-02-learning-resources.html#classification-vs-regression",
    "title": "Week 2: Chapter 2 Learning Videos (Supervised Learning + kNN)",
    "section": "Classification vs Regression",
    "text": "Classification vs Regression\nRegression vs. Classification — What’s the difference?\nby AWS Educate (2020s, ~5–10 min) — Beginner explanation of what changes when your target is a number vs a label."
  },
  {
    "objectID": "shared/guides/cmsc-2208/week-02/cmsc-2208-chap-02-learning-resources.html#generalization-why-we-split-into-training-vs-test",
    "href": "shared/guides/cmsc-2208/week-02/cmsc-2208-chap-02-learning-resources.html#generalization-why-we-split-into-training-vs-test",
    "title": "Week 2: Chapter 2 Learning Videos (Supervised Learning + kNN)",
    "section": "Generalization: why we split into training vs test",
    "text": "Generalization: why we split into training vs test\nTrain/Test Split (and why training accuracy can mislead you)\nby StatQuest (Josh Starmer) (2018–2020s, ~10–15 min) — Why we don’t evaluate on the same rows we trained on.\n\nCross Validation (bonus idea for small datasets)\nby StatQuest (Josh Starmer) (2018–2020s, ~10–15 min) — Why results can be unstable when you don’t have many rows."
  },
  {
    "objectID": "shared/guides/cmsc-2208/week-02/cmsc-2208-chap-02-learning-resources.html#underfitting-and-overfitting",
    "href": "shared/guides/cmsc-2208/week-02/cmsc-2208-chap-02-learning-resources.html#underfitting-and-overfitting",
    "title": "Week 2: Chapter 2 Learning Videos (Supervised Learning + kNN)",
    "section": "Underfitting and Overfitting",
    "text": "Underfitting and Overfitting\nOverfitting (video)\nby deeplizard (~4 min) — Explains what overfitting is and what it tends to look like when you compare training vs test performance.\n\nUnderfitting (video)\nby deeplizard (~3–4 min) — Explains underfitting (model too simple to learn the real pattern) and why it performs poorly."
  },
  {
    "objectID": "shared/guides/cmsc-2208/week-02/cmsc-2208-chap-02-learning-resources.html#k-nearest-neighbors-knn",
    "href": "shared/guides/cmsc-2208/week-02/cmsc-2208-chap-02-learning-resources.html#k-nearest-neighbors-knn",
    "title": "Week 2: Chapter 2 Learning Videos (Supervised Learning + kNN)",
    "section": "k-Nearest Neighbors (kNN)",
    "text": "k-Nearest Neighbors (kNN)\nK-Nearest Neighbors (kNN) clearly explained\nby StatQuest (Josh Starmer) (2018–2020s, ~10–15 min) — Neighbors “vote” and how changing k changes behavior."
  },
  {
    "objectID": "shared/guides/cmsc-2208/week-02/cmsc-2208-chap-02-learning-resources.html#accuracy-what-does-correct-mean",
    "href": "shared/guides/cmsc-2208/week-02/cmsc-2208-chap-02-learning-resources.html#accuracy-what-does-correct-mean",
    "title": "Week 2: Chapter 2 Learning Videos (Supervised Learning + kNN)",
    "section": "Accuracy: what does “correct” mean?",
    "text": "Accuracy: what does “correct” mean?\nThe Confusion Matrix (what accuracy is measuring)\nby StatQuest (Josh Starmer) (2018–2020s, ~10–15 min) — What “correct vs incorrect” means in classification."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "Use this site as your course handbook. It stays up to date all semester.\n\nUse the left sidebar to find weekly materials and guides.\nD2L is the starting point for announcements, grades, and submissions.\nCourse information (syllabus, schedule, policies, office hours) is maintained here.\n\n\nCourse workflow\n\nCheck D2L for announcements, deadlines, and any updates.\nRead the Weekly Overview on this site (Week 1, Week 2, …) and follow the links provided.\nComplete the work (assignments) and submit in D2L.\n\n\n\nSupport\n\nOffice hours: see the Office Hours page.\nZoom: Office Zoom Link\n\nHow to get help:\n\nUse Discord/email for course questions.\nAdd troubleshooting policy.\n\n\n\n\nInstructor contact\n\nInstructor: Joseph Silman\n\nEmail: jsilman@sctcc.edu\nPhone Number: (320) 308 - 6595\n\n\n\nQuick links\n\nSyllabus\nSchedule"
  },
  {
    "objectID": "course/schedule.html",
    "href": "course/schedule.html",
    "title": "CMSC 1236 Course Schedule",
    "section": "",
    "text": "Weekly module opens: Monday 8:00 AM\nAssignments due: Sunday 11:30 PM\nWork cadence:\n\nMon–Thu: work through reading + practice\nSun: graded items due (when assigned)\n\nSpring break: Mar 9–13, 2026\nFinal project block: Apr 27–May 10, 2026\nFinal project due: May 11, 2026",
    "crumbs": [
      "Home",
      "Course information",
      "Schedule"
    ]
  },
  {
    "objectID": "course/schedule.html#course-rhythm",
    "href": "course/schedule.html#course-rhythm",
    "title": "CMSC 1236 Course Schedule",
    "section": "",
    "text": "Weekly module opens: Monday 8:00 AM\nAssignments due: Sunday 11:30 PM\nWork cadence:\n\nMon–Thu: work through reading + practice\nSun: graded items due (when assigned)\n\nSpring break: Mar 9–13, 2026\nFinal project block: Apr 27–May 10, 2026\nFinal project due: May 11, 2026",
    "crumbs": [
      "Home",
      "Course information",
      "Schedule"
    ]
  },
  {
    "objectID": "course/schedule.html#weekly-schedule",
    "href": "course/schedule.html#weekly-schedule",
    "title": "CMSC 1236 Course Schedule",
    "section": "Weekly schedule",
    "text": "Weekly schedule\n\n\n\n\n\n\n\n\n\nWeek\nDates\nTopics\nReading\n\n\n\n\n1\nJan 12, 2026–Jan 18, 2026\nCourse environment + workflow (venv, Git, VS Code, run/submit). Start Virtual Pet v1 (menu loop skeleton, I/O patterns)\nLearning Python 6e Ch. 1–7 (finish by end of Week 2)\n\n\n2\nJan 19, 2026–Jan 25, 2026\nFinish Virtual Pet v1 (Pet class + conditionals + validation/invalid input + pickle save/load)\n\n\n\n3\nJan 26, 2026–Feb 01, 2026\nCore containers for CLI apps (lists/dicts/tuples) + file/persistence concepts to support the pet project\nLearning Python 6e Ch. 8–9\n\n\n4\nFeb 02, 2026–Feb 08, 2026\nStatements + assignment mechanics (unpacking, multiple assignment), practical output/formatting habits\nLearning Python 6e Ch. 10–11\n\n\n5\nFeb 09, 2026–Feb 15, 2026\nControl flow upgrade: if + match + truthiness for clean CLI logic\nLearning Python 6e Ch. 12\n\n\n6\nFeb 16, 2026–Feb 22, 2026\nLoop patterns used in real programs (validation loops, enumerate, zip, loop-else)\nLearning Python 6e Ch. 13\n\n\n7\nFeb 23, 2026–Mar 01, 2026\nIteration & comprehensions as “muscle memory” tools (readability + correctness)\nLearning Python 6e Ch. 14\n\n\n8\nMar 02, 2026–Mar 08, 2026\nFunctions as structure: boundaries, scope model, and argument patterns (foundation for refactoring)\nLearning Python 6e Ch. 16–18\n\n\n9\nMar 09, 2026–Mar 15, 2026\nSpring Break (no due dates)\n—\n\n\n10\nMar 16, 2026–Mar 22, 2026\nFunction “level-up”: advanced function topics + comprehensions/generators as programming habits\nLearning Python 6e Ch. 19–20\n\n\n11\nMar 23, 2026–Mar 29, 2026\nReal-program organization + reliability: modules/packages/__main__ + exceptions/context managers (selected)\nLearning Python 6e Ch. 22–25 + 33–36 (selected)\n\n\n12\nMar 30, 2026–Apr 05, 2026\nPivot to Fluent Python: data model mindset, why “dunder methods” matter\nFluent Python 2e Ch. 1\n\n\n13\nApr 06, 2026–Apr 12, 2026\nFunctions as objects for cleaner architecture (dispatch tables, callbacks, command systems)\nFluent Python 2e Ch. 7\n\n\n14\nApr 13, 2026–Apr 19, 2026\nFinal project proposal week: scope, constraints, milestones, repo plan, feature choices\nTargeted review of FP Ch. 1 & 7 + LP modules/exceptions (as needed)\n\n\n15\nApr 20, 2026–Apr 26, 2026\nIterators/generators for logs + reporting; “event stream” thinking for CLI apps\nFluent Python 2e Ch. 17\n\n\n16\nApr 27, 2026–May 03, 2026\nFinal project build week (student-chosen standalone CLI app)\nTargeted reading as needed\n\n\n17\nMay 04, 2026–May 10, 2026\nFinal polish: edge cases, reliability, run instructions, demo readiness\nTargeted review as needed",
    "crumbs": [
      "Home",
      "Course information",
      "Schedule"
    ]
  },
  {
    "objectID": "course/schedule.html#final-project-apr-27may-11",
    "href": "course/schedule.html#final-project-apr-27may-11",
    "title": "CMSC 1236 Course Schedule",
    "section": "Final project (Apr 27–May 11)",
    "text": "Final project (Apr 27–May 11)\nDeliverable (May 11, 2026):",
    "crumbs": [
      "Home",
      "Course information",
      "Schedule"
    ]
  },
  {
    "objectID": "assignments/week-03/index.html",
    "href": "assignments/week-03/index.html",
    "title": "Week 3 Assignments",
    "section": "",
    "text": "Submission location: No Dropbox submission this week. All work is completed in D2L."
  },
  {
    "objectID": "assignments/week-03/index.html#week-3-assignments",
    "href": "assignments/week-03/index.html#week-3-assignments",
    "title": "Week 3 Assignments",
    "section": "",
    "text": "Submission location: No Dropbox submission this week. All work is completed in D2L."
  },
  {
    "objectID": "assignments/week-03/index.html#part-1-reading",
    "href": "assignments/week-03/index.html#part-1-reading",
    "title": "Week 3 Assignments",
    "section": "Part 1: Reading",
    "text": "Part 1: Reading\nRead Learning Python (6e), Chapters 8–9.\nAs you read, focus on these ideas (these are also the ideas the quiz will test):\n\nNames and objects: variables are names that refer to objects\nIdentity vs equality: what is tests vs what == tests\nAliasing: how two names can refer to the same object through assignment\nMutability: what it means for an object (such as a list or dictionary) to be mutable\nRebinding vs mutation (lists): the difference between assigning a name to a new list and changing an existing list in place\nList slicing and slice assignment: what a slice means and how assigning to a slice changes a list\nNested list construction: why * repetition can create repeated references when building a list of lists\nDictionaries as mappings: key-based access, insertion order during iteration, and update patterns\nSafe dictionary access: membership tests with in and default-returning access with get\nSets: uniqueness, membership testing, and the hashability requirement for set elements\nTuples: indexing like other sequences and immutability (item assignment fails)\nCopying nested structures: what shallow copy and deep copy mean for nested lists"
  },
  {
    "objectID": "assignments/week-03/index.html#part-2-week-3-examples",
    "href": "assignments/week-03/index.html#part-2-week-3-examples",
    "title": "Week 3 Assignments",
    "section": "Part 2: Week 3 Examples",
    "text": "Part 2: Week 3 Examples\nUse the Week 3 examples notebook to make the Chapter 8–9 behaviors visible through short, print-based examples. The goal is to be able to predict and explain results when objects are reused, mutated, or nested.\n\nHere is the link to the Week 3 examples.\nDownload Jupyter Notebook"
  },
  {
    "objectID": "assignments/week-03/index.html#part-3-d2l-quiz",
    "href": "assignments/week-03/index.html#part-3-d2l-quiz",
    "title": "Week 3 Assignments",
    "section": "Part 3: D2L Quiz",
    "text": "Part 3: D2L Quiz\nComplete the Week 3 D2L quiz.\nThe quiz focuses on:\n\ndistinguishing identity and equality in code output (is vs ==)\nrecognizing when two names refer to the same object (aliasing)\ndetermining whether a list operation creates a new list (rebinding) or changes an existing list (mutation)\npredicting outcomes of slice assignment and nested list construction using *\ninterpreting dictionary behaviors: insertion order, membership tests (in), and safe access with get\nidentifying controlled dictionary update patterns using copy and update\nusing sets for uniqueness and explaining why unhashable types (such as lists) cannot be set elements\nidentifying tuple behaviors: indexing works, but item assignment fails\ndistinguishing shallow copy from deep copy for nested lists\nusing pathlib.Path for basic text file read/write and identifying where the file is created (the working directory)"
  },
  {
    "objectID": "assignments/week-03/index.html#completion-checklist",
    "href": "assignments/week-03/index.html#completion-checklist",
    "title": "Week 3 Assignments",
    "section": "Completion checklist",
    "text": "Completion checklist\n\nLearning Python 6e Chapters 8–9 reading\nWeek 3 examples notebook (run and review)\nWeek 3 D2L quiz"
  },
  {
    "objectID": "assignments/week-01/week-1-and-2-assignment.html",
    "href": "assignments/week-01/week-1-and-2-assignment.html",
    "title": "CMSC 1236 – Advanced Programming in Python",
    "section": "",
    "text": "Develop a Python program to simulate a virtual pet. This project will allow you to apply and demonstrate your understanding of Python basics, object-oriented programming, file handling using pickling, and user interaction through the console.\n\n\n\nThe Pet class is a core component of your Virtual Pet Simulator. It will model the behavior and state of your virtual pet. You will need to use conditional statements (if statements) in the methods of this class to simulate different scenarios based on the pet’s attributes.\n\nImplementing the Pet Class:\n\nFollow the provided UML diagram to create the Pet class with the attributes name, hunger, happiness, energy, color, and type.\nInitialize these attributes in the __init__ method. name, color, and type will be strings provided when a new pet is created, and hunger, happiness, and energy should start with random values between 0 and 10.\n\nUsing Conditional Statements in Class Methods:\n\nIn methods like feed, play, and rest, you will use if statements to check the state of the pet and decide what action to take.\n\n\n\n\n\n\n\n\n\nThe feed method is designed to simulate feeding the pet. Feeding the pet has implications on its hunger and happiness levels.\n\n\n\n\nReducing Hunger and Increasing Happiness:\n\nWhen the feed method is called, first check the pet’s current hunger level (self.hunger).\nIf self.hunger is greater than 0, it indicates that the pet is hungry. In this case, reduce self.hunger by 1 to represent feeding the pet. Ensure self.hunger does not go below 0.\nAfter feeding, increase self.happiness by 1. However, ensure that self.happiness does not exceed 10.\n\nManaging Happiness When Not Hungry:\n\nIf self.hunger is already at 0 (meaning the pet is not hungry), feeding the pet doesn’t reduce hunger will affect its happiness. Reduce self.happiness by 1, since overfeeding will cause discomfort.\n\nReturning Feedback:\n\nReturn a feedback string that reflects the pet’s reaction to being fed.\n\n\n\n\n\n\n\n\nThe play method simulates the interaction of playing with the pet. This activity affects the pet’s happiness and energy levels.\n\n\n\n\nHandling Sadness:\n\nBefore initiating play, check if the pet’s happiness level (self.happiness) is at 0.\nIf self.happiness is 0, it indicates that the pet is too sad to engage in play.\n\nHandling Tiredness:\n\nCheck the pet’s energy level (self.energy).\nIf self.energy is 0, it means the pet is too tired to play.\n\nPlaying with the Pet:\n\nIf the pet is neither too sad nor too tired (i.e., self.happiness is above 0 and self.energy is above 0), proceed to play with the pet.\nIncrease self.happiness by 1 to represent the positive effect of playing. However, ensure that self.happiness does not exceed 10.\nDecrease self.energy by 1 to account for the energy expended during play. However, it’s important to ensure that self.energy does not fall below 0.\n\nReturning Feedback:\n\nReturn a feedback string that reflects the pet’s reaction to playing.\n\n\n\n\n\n\n\n\nThe rest method is designed to simulate the pet resting, which affects its energy and happiness levels. Resting is essential for the pet to regain energy, but it might also affect its happiness if it becomes bored or inactive.\n\n\n\n\nIncreasing Energy:\n\nCheck the pet’s current energy level (self.energy).\nIf self.energy is less than 10, it indicates the pet could benefit from rest. Increase self.energy by 1 to represent the energy regained from resting. However, ensure that self.energy does not exceed 10.\n\nManaging Happiness When Energy is at Maximum:\n\nIf self.energy is already at 10 (meaning the pet is fully rested), resting will affect its happiness.\nIf self.energy is already at 10 and self.happiness is greater than 0, reduce self.happiness it by 1 to represent a slight decrease in happiness due to inactivity or boredom. Be sure to prevent self.happiness from going below 0.\n\nReturning Feedback:\n\nReturn a feedback string that reflects the pet’s reaction to resting.\n\n\n\n\n\n\n\n\nThe customize method allows the user to change the pet’s appearance by setting new values for the color and type attributes.\n\n\n\n\nSetting New Attributes:\n\nThe method takes two parameters, color and pet_type, and assigns them to the pet’s color and type attributes.\nThis allows the user to update the pet’s appearance during the simulation. Display the changed output to the user.\n\n\n\n\n\n\n\n\nThe status method provides a summary of the current state of the animal, including its hunger, happiness, energy, color, and type. This method is crucial for understanding the animal’s overall well-being at any given moment.\n\n\n\n\nCreating a Status Summary:\n\nThe method compiles a string that summarizes the animal’s current status.\nThis summary includes the animal’s name and its current hunger, happiness, energy, color, and type.\n\nString Formatting:\n\nCreate a readable and well-formatted summary.\nEach attribute (hunger, happiness, energy, color, type) should be on a separate line for clarity.\n\nReturning the Summary:\n\nThe method returns the formatted string.\n\n\n\n\n\n\n\n\nThe is_happy method is designed to evaluate the animal’s happiness level and determine if the animal is currently happy. This method provides a boolean result based on the happiness attribute.\n\n\n\n\nEvaluating Happiness:\n\nThe method assesses whether the animal’s happiness level (self.happiness) is below or above 5.\nIf self.happiness is above 5 the animal is considered to be happy.\n\nReturning a Boolean Result:\n\nThe method returns True if the animal’s happiness is above 5, indicating that the animal is happy.\nIt returns False if the happiness level is 5 or lower, indicating that the animal is not happy.\n\n\n\n\n\n\n\n\nYour main() function serves as the interaction hub between the user and their virtual pet. It will manage user inputs through a menu system and trigger appropriate actions based on the user’s choices.\n\n\n\n\nImplement a menu system that displays a list of possible actions the user can perform. These actions include:\n\nFeeding the pet\nPlaying with the pet\nLetting the pet rest\nChecking the pet’s status\nCustomizing the pet’s appearance\nSaving the pet’s state and exiting the program\n\nUse an input prompt to allow the user to select an action and then call the corresponding method from the Pet class.\n\n\n\n\n\nEnsure that the program gracefully handles invalid menu choices. (This needs to be demonstrated in submission video).\nDisplay an error message if the user inputs an invalid option and show the menu again for a valid selection.\n\n\n\n\n\n\nUse pickling to save and load the pet’s state. Implement a save_pet and a load_pet function in the main() for this purpose.\nEnsure the program can handle situations where no saved data exists.\n\n\n\n\n\nWelcome to the Virtual Pet Simulator!\n\nIn this program, you will create and take care of a virtual pet.\nYou can feed, play with, and let your pet rest to maintain its health and happiness.\nYou can also customize your pet's appearance and save its state to continue later.\nUse the menu to interact with your pet and make sure it stays happy and healthy!\n\nLet's get started!\n\nWhat is your pet's name? Joe\nChoose a color for your pet (e.g., red, blue, green): Blue\nChoose a type for your pet (e.g., dog, cat, bird): Dog\n\nHere is the current status of your pet:\n\nJoe's Status:\nColor: Blue\nType: Dog\nHunger: 8\nHappiness: 1\nEnergy: 10\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 9\nInvalid choice. Please enter a number between 1 and 6.\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 4\n\nJoe's Status:\nColor: Blue\nType: Dog\nHunger: 8\nHappiness: 1\nEnergy: 10\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 3\nJoe is rested and seems a bit bored.\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 1\nYou fed Joe. Joe seems happier after eating!\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 4\n\nJoe's Status:\nColor: Blue\nType: Dog\nHunger: 7\nHappiness: 2\nEnergy: 10\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 5\nChoose a color for your pet: Green\nChoose a type for your pet: Dog\nJoe is now a Green Dog!\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 6\nPet state saved. Goodbye!\n\n\n\nWelcome to the Virtual Pet Simulator!\n\nIn this program, you will create and take care of a virtual pet.\nYou can feed, play with, and let your pet rest to maintain its health and happiness.\nYou can also customize your pet's appearance and save its state to continue later.\nUse the menu to interact with your pet and make sure it stays happy and healthy!\n\nLet's get started!\n\n\nHere is the current status of your pet:\n\nJoe's Status:\nColor: Green\nType: Dog\nHunger: 7\nHappiness: 2\nEnergy: 10\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 2\nPlaying with Joe was fun!\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 4\nJoe's Status:\nColor: Green\nType: Dog\nHunger: 7\nHappiness: 3\nEnergy: 9\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 6\nPet state saved. Goodbye!\n\n\n  +---------------------+\n  |        Pet          |\n  +---------------------+\n  | - name: str         |\n  | - hunger: int       |\n  | - happiness: int    |\n  | - energy: int       |\n  | - color: str        |\n  | - type: str         |\n  +---------------------+\n  | + __init__(name, color, pet_type) |\n  | + feed()            |\n  | + play()            |\n  | + rest()            |\n  | + customize(color, pet_type) |\n  | + status(): str     |\n  | + is_happy(): bool  |\n  +---------------------+"
  },
  {
    "objectID": "assignments/week-01/week-1-and-2-assignment.html#overview",
    "href": "assignments/week-01/week-1-and-2-assignment.html#overview",
    "title": "CMSC 1236 – Advanced Programming in Python",
    "section": "",
    "text": "Develop a Python program to simulate a virtual pet. This project will allow you to apply and demonstrate your understanding of Python basics, object-oriented programming, file handling using pickling, and user interaction through the console."
  },
  {
    "objectID": "assignments/week-01/week-1-and-2-assignment.html#pet-class",
    "href": "assignments/week-01/week-1-and-2-assignment.html#pet-class",
    "title": "CMSC 1236 – Advanced Programming in Python",
    "section": "",
    "text": "The Pet class is a core component of your Virtual Pet Simulator. It will model the behavior and state of your virtual pet. You will need to use conditional statements (if statements) in the methods of this class to simulate different scenarios based on the pet’s attributes.\n\nImplementing the Pet Class:\n\nFollow the provided UML diagram to create the Pet class with the attributes name, hunger, happiness, energy, color, and type.\nInitialize these attributes in the __init__ method. name, color, and type will be strings provided when a new pet is created, and hunger, happiness, and energy should start with random values between 0 and 10.\n\nUsing Conditional Statements in Class Methods:\n\nIn methods like feed, play, and rest, you will use if statements to check the state of the pet and decide what action to take."
  },
  {
    "objectID": "assignments/week-01/week-1-and-2-assignment.html#method-implementations",
    "href": "assignments/week-01/week-1-and-2-assignment.html#method-implementations",
    "title": "CMSC 1236 – Advanced Programming in Python",
    "section": "",
    "text": "The feed method is designed to simulate feeding the pet. Feeding the pet has implications on its hunger and happiness levels.\n\n\n\n\nReducing Hunger and Increasing Happiness:\n\nWhen the feed method is called, first check the pet’s current hunger level (self.hunger).\nIf self.hunger is greater than 0, it indicates that the pet is hungry. In this case, reduce self.hunger by 1 to represent feeding the pet. Ensure self.hunger does not go below 0.\nAfter feeding, increase self.happiness by 1. However, ensure that self.happiness does not exceed 10.\n\nManaging Happiness When Not Hungry:\n\nIf self.hunger is already at 0 (meaning the pet is not hungry), feeding the pet doesn’t reduce hunger will affect its happiness. Reduce self.happiness by 1, since overfeeding will cause discomfort.\n\nReturning Feedback:\n\nReturn a feedback string that reflects the pet’s reaction to being fed.\n\n\n\n\n\n\n\n\nThe play method simulates the interaction of playing with the pet. This activity affects the pet’s happiness and energy levels.\n\n\n\n\nHandling Sadness:\n\nBefore initiating play, check if the pet’s happiness level (self.happiness) is at 0.\nIf self.happiness is 0, it indicates that the pet is too sad to engage in play.\n\nHandling Tiredness:\n\nCheck the pet’s energy level (self.energy).\nIf self.energy is 0, it means the pet is too tired to play.\n\nPlaying with the Pet:\n\nIf the pet is neither too sad nor too tired (i.e., self.happiness is above 0 and self.energy is above 0), proceed to play with the pet.\nIncrease self.happiness by 1 to represent the positive effect of playing. However, ensure that self.happiness does not exceed 10.\nDecrease self.energy by 1 to account for the energy expended during play. However, it’s important to ensure that self.energy does not fall below 0.\n\nReturning Feedback:\n\nReturn a feedback string that reflects the pet’s reaction to playing.\n\n\n\n\n\n\n\n\nThe rest method is designed to simulate the pet resting, which affects its energy and happiness levels. Resting is essential for the pet to regain energy, but it might also affect its happiness if it becomes bored or inactive.\n\n\n\n\nIncreasing Energy:\n\nCheck the pet’s current energy level (self.energy).\nIf self.energy is less than 10, it indicates the pet could benefit from rest. Increase self.energy by 1 to represent the energy regained from resting. However, ensure that self.energy does not exceed 10.\n\nManaging Happiness When Energy is at Maximum:\n\nIf self.energy is already at 10 (meaning the pet is fully rested), resting will affect its happiness.\nIf self.energy is already at 10 and self.happiness is greater than 0, reduce self.happiness it by 1 to represent a slight decrease in happiness due to inactivity or boredom. Be sure to prevent self.happiness from going below 0.\n\nReturning Feedback:\n\nReturn a feedback string that reflects the pet’s reaction to resting.\n\n\n\n\n\n\n\n\nThe customize method allows the user to change the pet’s appearance by setting new values for the color and type attributes.\n\n\n\n\nSetting New Attributes:\n\nThe method takes two parameters, color and pet_type, and assigns them to the pet’s color and type attributes.\nThis allows the user to update the pet’s appearance during the simulation. Display the changed output to the user.\n\n\n\n\n\n\n\n\nThe status method provides a summary of the current state of the animal, including its hunger, happiness, energy, color, and type. This method is crucial for understanding the animal’s overall well-being at any given moment.\n\n\n\n\nCreating a Status Summary:\n\nThe method compiles a string that summarizes the animal’s current status.\nThis summary includes the animal’s name and its current hunger, happiness, energy, color, and type.\n\nString Formatting:\n\nCreate a readable and well-formatted summary.\nEach attribute (hunger, happiness, energy, color, type) should be on a separate line for clarity.\n\nReturning the Summary:\n\nThe method returns the formatted string.\n\n\n\n\n\n\n\n\nThe is_happy method is designed to evaluate the animal’s happiness level and determine if the animal is currently happy. This method provides a boolean result based on the happiness attribute.\n\n\n\n\nEvaluating Happiness:\n\nThe method assesses whether the animal’s happiness level (self.happiness) is below or above 5.\nIf self.happiness is above 5 the animal is considered to be happy.\n\nReturning a Boolean Result:\n\nThe method returns True if the animal’s happiness is above 5, indicating that the animal is happy.\nIt returns False if the happiness level is 5 or lower, indicating that the animal is not happy.\n\n\n\n\n\n\n\n\nYour main() function serves as the interaction hub between the user and their virtual pet. It will manage user inputs through a menu system and trigger appropriate actions based on the user’s choices.\n\n\n\n\nImplement a menu system that displays a list of possible actions the user can perform. These actions include:\n\nFeeding the pet\nPlaying with the pet\nLetting the pet rest\nChecking the pet’s status\nCustomizing the pet’s appearance\nSaving the pet’s state and exiting the program\n\nUse an input prompt to allow the user to select an action and then call the corresponding method from the Pet class.\n\n\n\n\n\nEnsure that the program gracefully handles invalid menu choices. (This needs to be demonstrated in submission video).\nDisplay an error message if the user inputs an invalid option and show the menu again for a valid selection.\n\n\n\n\n\n\nUse pickling to save and load the pet’s state. Implement a save_pet and a load_pet function in the main() for this purpose.\nEnsure the program can handle situations where no saved data exists."
  },
  {
    "objectID": "assignments/week-01/week-1-and-2-assignment.html#sample-output",
    "href": "assignments/week-01/week-1-and-2-assignment.html#sample-output",
    "title": "CMSC 1236 – Advanced Programming in Python",
    "section": "",
    "text": "Welcome to the Virtual Pet Simulator!\n\nIn this program, you will create and take care of a virtual pet.\nYou can feed, play with, and let your pet rest to maintain its health and happiness.\nYou can also customize your pet's appearance and save its state to continue later.\nUse the menu to interact with your pet and make sure it stays happy and healthy!\n\nLet's get started!\n\nWhat is your pet's name? Joe\nChoose a color for your pet (e.g., red, blue, green): Blue\nChoose a type for your pet (e.g., dog, cat, bird): Dog\n\nHere is the current status of your pet:\n\nJoe's Status:\nColor: Blue\nType: Dog\nHunger: 8\nHappiness: 1\nEnergy: 10\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 9\nInvalid choice. Please enter a number between 1 and 6.\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 4\n\nJoe's Status:\nColor: Blue\nType: Dog\nHunger: 8\nHappiness: 1\nEnergy: 10\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 3\nJoe is rested and seems a bit bored.\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 1\nYou fed Joe. Joe seems happier after eating!\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 4\n\nJoe's Status:\nColor: Blue\nType: Dog\nHunger: 7\nHappiness: 2\nEnergy: 10\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 5\nChoose a color for your pet: Green\nChoose a type for your pet: Dog\nJoe is now a Green Dog!\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 6\nPet state saved. Goodbye!"
  },
  {
    "objectID": "assignments/week-01/week-1-and-2-assignment.html#starting-the-program-with-a-file-created",
    "href": "assignments/week-01/week-1-and-2-assignment.html#starting-the-program-with-a-file-created",
    "title": "CMSC 1236 – Advanced Programming in Python",
    "section": "",
    "text": "Welcome to the Virtual Pet Simulator!\n\nIn this program, you will create and take care of a virtual pet.\nYou can feed, play with, and let your pet rest to maintain its health and happiness.\nYou can also customize your pet's appearance and save its state to continue later.\nUse the menu to interact with your pet and make sure it stays happy and healthy!\n\nLet's get started!\n\n\nHere is the current status of your pet:\n\nJoe's Status:\nColor: Green\nType: Dog\nHunger: 7\nHappiness: 2\nEnergy: 10\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 2\nPlaying with Joe was fun!\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 4\nJoe's Status:\nColor: Green\nType: Dog\nHunger: 7\nHappiness: 3\nEnergy: 9\n\nWhat would you like to do with your pet?\n1: Feed\n2: Play\n3: Rest\n4: Check Status\n5: Customize Pet\n6: Save and Exit\nEnter your choice: 6\nPet state saved. Goodbye!\n\n\n  +---------------------+\n  |        Pet          |\n  +---------------------+\n  | - name: str         |\n  | - hunger: int       |\n  | - happiness: int    |\n  | - energy: int       |\n  | - color: str        |\n  | - type: str         |\n  +---------------------+\n  | + __init__(name, color, pet_type) |\n  | + feed()            |\n  | + play()            |\n  | + rest()            |\n  | + customize(color, pet_type) |\n  | + status(): str     |\n  | + is_happy(): bool  |\n  +---------------------+"
  },
  {
    "objectID": "assignments/week-01/environment-setup.html",
    "href": "assignments/week-01/environment-setup.html",
    "title": "CMSC 1236 – Python Environment Setup (Windows)",
    "section": "",
    "text": "For CMSC 1236, we will create a separate Python environment so nothing conflicts with your other classes."
  },
  {
    "objectID": "assignments/week-01/environment-setup.html#step-2-create-your-course-folder-on-the-root-drive",
    "href": "assignments/week-01/environment-setup.html#step-2-create-your-course-folder-on-the-root-drive",
    "title": "CMSC 1236 – Python Environment Setup (Windows)",
    "section": "Step 2 — Create your course folder on the root drive",
    "text": "Step 2 — Create your course folder on the root drive\nYour CMSC 1236 directory must be created on the root of the C: drive:\n\nC:\\cmsc-1236\n\nInside it, create these folders:\n\nassignments\nnotes\nprojects\n\nCreating the course folder on the root drive helps avoid common Windows problems:\n\nShort, predictable paths (fewer issues with tools that don’t like long file paths).\nAvoids OneDrive syncing (Desktop/Documents are often synced; syncing can lock files and break builds/tools).\nMakes Git + terminals simpler (easy to navigate, fewer permission surprises).\nKeeps course work separate from other software setups (so you don’t accidentally mix files/tools between courses).\n\n\nCMD commands (Command Prompt)\n\nOpen Command Prompt (cmd).\nGo to the root of the C: drive:\n\ncd\\\n\nCreate the course folder:\n\nmkdir cmsc-1236\n\nMove into the course folder:\n\ncd \\cmsc-1236\n\nCreate the three required subfolders:\n\nmkdir assignments\nmkdir notes\nmkdir projects\n\n\nVerify the folder structure\nRun:\ndir\nYour folder structure should look like similar to the following:\nC:\\cmsc-1236\\\n  assignments\\\n  notes\\\n  projects\\"
  },
  {
    "objectID": "assignments/week-01/environment-setup.html#step-3-create-the-cmsc-1236-python-environment",
    "href": "assignments/week-01/environment-setup.html#step-3-create-the-cmsc-1236-python-environment",
    "title": "CMSC 1236 – Python Environment Setup (Windows)",
    "section": "Step 3 — Create the CMSC 1236 Python environment",
    "text": "Step 3 — Create the CMSC 1236 Python environment\nWe will create a dedicated environment named:\n\ncmsc1236\n\nThis environment is separate from any miniconda environments you may be using in other courses, so nothing conflicts.\nA dedicated environment ensures that we:\n\nKeep CMSC 1236 packages separate from other classes/tools\nEnsure the course runs on a consistent Python version\n\n\nCreate the environment (Command Prompt)\n\nOpen Command Prompt (cmd)\n\nGo to your course folder (if not already there):\n\ncd \\cmsc-1236\n\nCreate the environment folder using Python’s built-in venv tool:\n\npy -m venv cmsc1236\n\n\nActivate the environment (Command Prompt)\nRun:\ncmsc1236\\Scripts\\activate\nWhen it activates, your prompt will look like this:\n(cmsc1236) C:\\cmsc-1236&gt;\n\n\nVerify the environment is working\nRun:\npython --version\nYou should see a Python version printed:\nPython 3.xx.x\n\n\nDeactivate the environment\nWhen you are finished:\ndeactivate"
  },
  {
    "objectID": "assignments/week-01/environment-setup.html#step-4-initialize-git-in-your-course-folder",
    "href": "assignments/week-01/environment-setup.html#step-4-initialize-git-in-your-course-folder",
    "title": "CMSC 1236 – Python Environment Setup (Windows)",
    "section": "Step 4 — Initialize Git in your course folder",
    "text": "Step 4 — Initialize Git in your course folder\nWe use Git to track your work over time and to make submitting or backing up your work easier.\nThis step creates a .git folder that stores your work history.\n\nInitialize the repository\nOpen Command Prompt (cmd) and run:\ncd C:\\cmsc-1236\ngit init\n\n\nCreate a .gitignore file\nGit does not create a .gitignore automatically. You will create it so that you don’t accidentally commit:\n\nPython cache files\neditor settings\ntemporary files\n\nIn C:\\cmsc-1236, create a file named:\n.gitignore\nPaste the following into it:\n# Python cache\n__pycache__/\n*.pyc\n\n# Environment / OS clutter\n.DS_Store\nThumbs.db\n\n# VS Code\n.vscode/\n\n# Local environment folder \ncmsc1236/\n\n# Common local files\n*.log\n*.tmp"
  },
  {
    "objectID": "assignments/week-01/environment-setup.html#step-5-set-vs-code-to-use-the-cmsc-1236-environment",
    "href": "assignments/week-01/environment-setup.html#step-5-set-vs-code-to-use-the-cmsc-1236-environment",
    "title": "CMSC 1236 – Python Environment Setup (Windows)",
    "section": "Step 5 — Set VS Code to use the CMSC 1236 environment",
    "text": "Step 5 — Set VS Code to use the CMSC 1236 environment\nIn this step, you will tell VS Code which Python interpreter to use for this course so that:\n\nRun/Debug uses the correct Python\nThe integrated terminal runs the correct Python\nYour assignments behave consistently across machines\n\n\nNote: This environment is separate from the Miniconda environments you may be using in other courses, so nothing conflicts.\n\n\nOpen your course folder in VS Code\n\n\nVS Code stores interpreter settings per folder/project\nOpening the correct folder ensures the interpreter you select is tied to CMSC 1236 only\n\n\nSelect the correct Python interpreter\n\n\n\nSelect View → Command Palette or Press: Ctrl + Shift + P\n\nType: Python: Select Interpreter\nChoose the interpreter that points to the course environment:\n\nC:\\cmsc-1236\\cmsc1236\\Scripts\\python.exe\nIf you do not see it:\n\nChoose Enter interpreter path…\nThen browse to: C:\\cmsc-1236\\cmsc1236\\Scripts\\python.exe\n\n\nVerify in the VS Code Terminal (Command Prompt)\n\n\n\nIn VS Code, open a CMD Prompt terminal:\n\nTerminal → New Terminal\n\nConfirm you are in the course folder. If not, run:\n\ncd C:\\cmsc-1236\n\nActivate the course environment:\n\ncmsc1236\\Scripts\\activate\n\nVerify that Python is coming from the course environment:\n\nwhere python\nExpected output includes a path like:\nC:\\cmsc-1236\\cmsc1236\\Scripts\\python.exe\n\nConfirm the Python version:\n\npython --version\n\nIf where python does NOT point into C:\\cmsc-1236\\cmsc1236\\..., you are not using the course environment\nFixing it here prevents “it works on my machine” problems later"
  },
  {
    "objectID": "assignments/week-01/environment-setup.html#step-6-test-python-from-the-vs-code-terminal",
    "href": "assignments/week-01/environment-setup.html#step-6-test-python-from-the-vs-code-terminal",
    "title": "CMSC 1236 – Python Environment Setup (Windows)",
    "section": "Step 6 — Test Python from the VS Code terminal",
    "text": "Step 6 — Test Python from the VS Code terminal\nCreate a new folder:\nmkdir C:\\cmsc-1236\\projects\\week-01\nCreate a new python file called:\n\ntest_env.py\n\nPaste this code:\nimport sys\n\nprint(\"Python version:\", sys.version)\nprint(\"Python executable:\", sys.executable)\nRun it in the VS Code terminal:\ncd C:\\cmsc-1236\\projects\\week-01\\\npython test_env.py\nYou should see:\n\nA Python 3.xx.x version output\nA path showing it is running from the cmsc1236 environment"
  },
  {
    "objectID": "assignments/week-01/environment-setup.html#step-7-import-the-book-example-code",
    "href": "assignments/week-01/environment-setup.html#step-7-import-the-book-example-code",
    "title": "CMSC 1236 – Python Environment Setup (Windows)",
    "section": "Step 7 — Import the book example code",
    "text": "Step 7 — Import the book example code\nYou’ll keep the books’ example code in your course folder so you can quickly reference working examples while reading and while completing assignments.\n\nCreate a place to store the book code\nOpen Command Prompt (cmd) and run:\ncd C:\\cmsc-1236\nmkdir book\ncd book\nAfter this step, you’ll have:\nC:\\cmsc-1236\\book\\ (this is where both books’ code will live)\n\n\n\nFluent Python (2nd Edition) — clone the official GitHub repo\nIn the same cmd window (you should still be in C:\\cmsc-1236\\book), run:\ngit clone https://github.com/fluentpython/example-code-2e.git\nThis creates:\nC:\\cmsc-1236\\book\\fluent-python-2e\\\n\n\nLearning Python (6th Edition) — download the official examples ZIP\nLearning Python’s official examples are provided as a ZIP download from the book’s site (not a GitHub repo).\n\nOpen this page in your browser: https://learning-python.com/LP6E-code.html\nClick LP6E.zip ⇦ Fetch and unzip and download it.\n\n\n\nUnzip it\n\nRight-click the ZIP → Extract All…\nExtract into: C:\\cmsc-1236\\book\\\n\nAfter unzipping, you should see an LP6E\\ folder in C:\\cmsc-1236\\book\\."
  },
  {
    "objectID": "assignments/week-01/environment-setup.html#you-are-done",
    "href": "assignments/week-01/environment-setup.html#you-are-done",
    "title": "CMSC 1236 – Python Environment Setup (Windows)",
    "section": "You are done",
    "text": "You are done\nAt this point:\n\nYour course folder exists at C:\\cmsc-1236\nGit is initialized\nYour cmsc1236 Python environment is created and working\nVS Code is configured to use the course environment\nYou can now work normally in VS Code and run programs from the terminal"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "assignments/week-01/cmsc-1217-chap-03-learning-resoursces.html",
    "href": "assignments/week-01/cmsc-1217-chap-03-learning-resoursces.html",
    "title": "Week 2: Chapter 3 Additional Reference Videos (Files, Parsing, Comprehensions, Lambda, Generators)",
    "section": "",
    "text": "Try / Except | Python (Tutorial)\nby Socratica — A focused explanation of what try and except actually do, and why this pattern is useful when you want to keep processing after one failure."
  },
  {
    "objectID": "assignments/week-01/cmsc-1217-chap-03-learning-resoursces.html#exceptions-and-safe-processing-tryexcept",
    "href": "assignments/week-01/cmsc-1217-chap-03-learning-resoursces.html#exceptions-and-safe-processing-tryexcept",
    "title": "Week 2: Chapter 3 Additional Reference Videos (Files, Parsing, Comprehensions, Lambda, Generators)",
    "section": "",
    "text": "Try / Except | Python (Tutorial)\nby Socratica — A focused explanation of what try and except actually do, and why this pattern is useful when you want to keep processing after one failure."
  },
  {
    "objectID": "assignments/week-01/cmsc-1217-chap-03-learning-resoursces.html#list-comprehensions-compact-build-a-new-list-loops",
    "href": "assignments/week-01/cmsc-1217-chap-03-learning-resoursces.html#list-comprehensions-compact-build-a-new-list-loops",
    "title": "Week 2: Chapter 3 Additional Reference Videos (Files, Parsing, Comprehensions, Lambda, Generators)",
    "section": "List comprehensions (compact “build a new list” loops)",
    "text": "List comprehensions (compact “build a new list” loops)\nLearn Python LIST COMPREHENSIONS in 10 minutes!\nby Bro Code — Quick overview of list comprehension syntax, comparing them to regular for loops with many clear examples.\n\nList Comprehensions | Python (Tutorial)\nby CS Dojo — List comprehension basics in Python - let’s go!\n\nPython Tutorial: List Comprehensions\nby Corey Schafer — A deeper walkthrough showing common patterns and how comprehensions relate to the equivalent loop form."
  },
  {
    "objectID": "assignments/week-01/cmsc-1217-chap-03-learning-resoursces.html#lambda-a-small-function-used-inline",
    "href": "assignments/week-01/cmsc-1217-chap-03-learning-resoursces.html#lambda-a-small-function-used-inline",
    "title": "Week 2: Chapter 3 Additional Reference Videos (Files, Parsing, Comprehensions, Lambda, Generators)",
    "section": "Lambda (a small function used inline)",
    "text": "Lambda (a small function used inline)\nLearn Python LAMBDA in 6 minutes!\nby Bro Code — Introduces lambda functions as short, anonymous functions and shows common use cases like sorting and mapping.\n\nPython Tutorial: Lambda Functions\nby Corey Schafer — Explains what a lambda is, when it’s useful, and how it connects to patterns like sorted(..., key=...) and max(..., key=...)."
  },
  {
    "objectID": "assignments/week-01/cmsc-1217-chap-03-learning-resoursces.html#generators-and-iteration-yield-streaming-one-row-at-a-time",
    "href": "assignments/week-01/cmsc-1217-chap-03-learning-resoursces.html#generators-and-iteration-yield-streaming-one-row-at-a-time",
    "title": "Week 2: Chapter 3 Additional Reference Videos (Files, Parsing, Comprehensions, Lambda, Generators)",
    "section": "Generators and iteration (yield, streaming one row at a time)",
    "text": "Generators and iteration (yield, streaming one row at a time)\nPython Generators Explained\nby Programming with Mosh — Clear, beginner-friendly explanation of generators, how they work, and why they’re useful for memory-efficient data processing.\n\nPython Tutorial: Generators - How to use them and the benefits you receive\nby Corey Schafer — A practical explanation of yield, how generator functions behave differently from normal functions, and what changes when you iterate over a generator."
  },
  {
    "objectID": "assignments/week-01/index.html",
    "href": "assignments/week-01/index.html",
    "title": "Week 1 Assignment",
    "section": "",
    "text": "Complete the Environment Setup:\n\nEnvironment Setup\n\nWeek 1 and 2 Python Review Project\n\nVirtual Pet Project",
    "crumbs": [
      "Home",
      "Weekly Assignments",
      "Week 1"
    ]
  },
  {
    "objectID": "assignments/week-01/index.html#assignment",
    "href": "assignments/week-01/index.html#assignment",
    "title": "Week 1 Assignment",
    "section": "",
    "text": "Complete the Environment Setup:\n\nEnvironment Setup\n\nWeek 1 and 2 Python Review Project\n\nVirtual Pet Project",
    "crumbs": [
      "Home",
      "Weekly Assignments",
      "Week 1"
    ]
  },
  {
    "objectID": "assignments/week-01/index.html#what-to-work-on-this-week",
    "href": "assignments/week-01/index.html#what-to-work-on-this-week",
    "title": "Week 1 Assignment",
    "section": "What to work on this week",
    "text": "What to work on this week\n\nSet up your course environment and confirm you can run .py files using the correct interpreter.\nInitialize a Git repository and commit your initial working setup.\nBegin Virtual Pet v1 by implementing the menu loop skeleton and basic input/output patterns.\nAdd input validation for menu selection so invalid input does not terminate the program.",
    "crumbs": [
      "Home",
      "Weekly Assignments",
      "Week 1"
    ]
  },
  {
    "objectID": "assignments/week-01/index.html#reading",
    "href": "assignments/week-01/index.html#reading",
    "title": "Week 1 Assignment",
    "section": "Reading",
    "text": "Reading\nRead Learning Python 6e, Chapters 1–7 by the end of Week 2. The purpose of this reading is review and reference: you are expected to recognize core language features (types, expressions, statements, control flow, and program structure) from Structured Programming Logic and to be able to look up details as you implement the Virtual Pet project. You do not need to memorize the chapters; you should be able to locate and apply relevant examples when you encounter unfamiliar syntax or behavior.",
    "crumbs": [
      "Home",
      "Weekly Assignments",
      "Week 1"
    ]
  },
  {
    "objectID": "assignments/week-01/index.html#complete-course-agreement-quiz-by-wednesday-1130pm",
    "href": "assignments/week-01/index.html#complete-course-agreement-quiz-by-wednesday-1130pm",
    "title": "Week 1 Assignment",
    "section": "Complete Course Agreement Quiz by Wednesday 11:30PM",
    "text": "Complete Course Agreement Quiz by Wednesday 11:30PM\nThis needs to be done to avoid being dropped from the course.",
    "crumbs": [
      "Home",
      "Weekly Assignments",
      "Week 1"
    ]
  },
  {
    "objectID": "assignments/week-01/index.html#submission",
    "href": "assignments/week-01/index.html#submission",
    "title": "Week 1 Assignment",
    "section": "Submission",
    "text": "Submission\nSubmit the complete project during Week 2.",
    "crumbs": [
      "Home",
      "Weekly Assignments",
      "Week 1"
    ]
  },
  {
    "objectID": "assignments/week-02/index.html",
    "href": "assignments/week-02/index.html",
    "title": "Virtual Pet Submission Deliverables",
    "section": "",
    "text": "Submission location: All items are submitted in D2L (Week 2 dropbox).",
    "crumbs": [
      "Home",
      "Weekly Assignments",
      "Week 2"
    ]
  },
  {
    "objectID": "assignments/week-02/index.html#part-1-code-submission",
    "href": "assignments/week-02/index.html#part-1-code-submission",
    "title": "Virtual Pet Submission Deliverables",
    "section": "Part 1: Code submission",
    "text": "Part 1: Code submission\nSubmit your Python source files to the Week 2 Dropbox.\n\nRequired files\nUpload the following files:\n\nMain program\nFilename: lastname_main.py\nPet class\nFilename: lastname_pet.py\nContains:\n\nthe Pet class and required methods\nclass attributes and logic that control pet behavior\n\n\n\n\nImplementation requirements (read carefully)\nYour code will be reviewed for adherence to the assignment’s required functions, method names, and behaviors. The code submission and video explanation are evaluated as a single submission: the video supports your assessment, but it does not replace the implementation requirements. Missing required features or incorrect function/method names will affect the overall score, even if the explanation is strong.\n\nYou must implement the required Pet methods using the names specified in the assignment (feed, play, rest, customize, status, is_happy).\nYour main() workflow must include the required persistence functions named save_pet and load_pet.\nNames matter: method/function names, parameters, and expected behaviors must match the assignment instructions so your work can be evaluated consistently.\n\nThis assignment is intended to assess core Python fundamentals. Use basic Python only.\n\n\nAI-generated content\nYou may use AI tools for support, but you remain responsible for the final submission.",
    "crumbs": [
      "Home",
      "Weekly Assignments",
      "Week 2"
    ]
  },
  {
    "objectID": "assignments/week-02/index.html#part-2-video-explanation",
    "href": "assignments/week-02/index.html#part-2-video-explanation",
    "title": "Virtual Pet Submission Deliverables",
    "section": "Part 2: Video explanation",
    "text": "Part 2: Video explanation\n\nVideo Submission Instructions\nRecord a video of yourself explaining your code and design choices. The focus is your understanding of how the program works and why you implemented it the way you did. Use the rubric as a guide for what to cover.\nRequirements - Clear video and audio quality - Introduce yourself, the assignment, and course at the beginning of the video\n\n\nWhat to include in the video\nYour video must include:\n\nProgram demonstration\n\nStart the program and create a new pet (name, color, type).\nShow the menu loop running and responding to user input.\nDemonstrate invalid input handling (enter an invalid choice and show the program displays an error and continues).\nDemonstrate each menu action at least once:\n\nFeed\nPlay\nRest\nCheck Status\nCustomize Pet\nSave and Exit (confirm a save message is shown)\n\n\nPersistence demonstration (pickling)\n\nShow saving the pet’s state using Save and Exit.\nRestart the program and demonstrate loading the saved pet state (program continues with the existing pet rather than creating a new one).\nBriefly explain where the data is stored and what gets saved.\n\nCode walkthrough\n\nExplain the Pet class attributes and why they represent the pet’s state (name, hunger, happiness, energy, color, type).\nExplain the logic in feed, play, and rest.\nExplain how the menu maps user choices to method calls.\nExplain how invalid input is handled (type and/or range).\n\nLessons Learned (required for credit) Discuss this at the end:\n\nWhat was most difficult\nWhat you changed after testing\nWhat you would improve next time",
    "crumbs": [
      "Home",
      "Weekly Assignments",
      "Week 2"
    ]
  },
  {
    "objectID": "assignments/week-02/index.html#part-3-design-guide-requirement",
    "href": "assignments/week-02/index.html#part-3-design-guide-requirement",
    "title": "Virtual Pet Submission Deliverables",
    "section": "Part 3: Design guide requirement",
    "text": "Part 3: Design guide requirement\nEnsure you follow the Design Guide: - Design Guide (CMSC 1203)",
    "crumbs": [
      "Home",
      "Weekly Assignments",
      "Week 2"
    ]
  },
  {
    "objectID": "assignments/week-02/index.html#d2l-submission-checklist-week-2-dropbox",
    "href": "assignments/week-02/index.html#d2l-submission-checklist-week-2-dropbox",
    "title": "Virtual Pet Submission Deliverables",
    "section": "D2L submission checklist (Week 2 dropbox)",
    "text": "D2L submission checklist (Week 2 dropbox)\nSubmit the following items:\n\nPython files (upload)\n\nlastname_main.py\nlastname_pet.py\n\n\n\nVideo submission\n\nUpload the video using to Kaltura Mediaspace\nName your video file link: lastname_Pet_video\nLink to the Kaltura video in the Assignment Dropbox",
    "crumbs": [
      "Home",
      "Weekly Assignments",
      "Week 2"
    ]
  },
  {
    "objectID": "assignments/week-03/week-3-demo.html",
    "href": "assignments/week-03/week-3-demo.html",
    "title": "CMSC 1236 — Week 3 Demo",
    "section": "",
    "text": "CMSC 1203 introduced lists, dictionaries, and sets with an emphasis on correct use: create a data structure, loop over it, and produce correct output. Chapters 8–9 build on that foundation by explaining how Python’s built-in types behave at runtime.\nIn this notebook, the term collection type refers to a built-in type that groups multiple values into a single object (for example: list, dict, set, and tuple). The goal is to understand how these types store and share references, and how operations on them affect program behavior as code and data structures become larger.\nAfter completing these examples, you should be able to:\n\nexplain the difference between identity and equality (is vs ==)\ndistinguish rebinding from in-place mutation and predict when aliasing causes a change to appear in more than one place\nuse list operations shown in the reading (including slice assignment and nested list construction) and predict when they modify an existing list\ndescribe key dictionary behaviors emphasized in the reading: insertion order, safe key access, and controlled updates\nuse sets for uniqueness and understand why set elements must be hashable\nexplain why tuples are used for fixed groupings and why item assignment is not allowed\ncopy nested structures intentionally by choosing between a shallow copy and a deep copy\nread and write a text file using pathlib.Path (read_text() and write_text())"
  },
  {
    "objectID": "assignments/week-03/week-3-demo.html#learning-python-6e-ch.-89-collections-sequences-mappings-sets-pathlib",
    "href": "assignments/week-03/week-3-demo.html#learning-python-6e-ch.-89-collections-sequences-mappings-sets-pathlib",
    "title": "CMSC 1236 — Week 3 Demo",
    "section": "",
    "text": "CMSC 1203 introduced lists, dictionaries, and sets with an emphasis on correct use: create a data structure, loop over it, and produce correct output. Chapters 8–9 build on that foundation by explaining how Python’s built-in types behave at runtime.\nIn this notebook, the term collection type refers to a built-in type that groups multiple values into a single object (for example: list, dict, set, and tuple). The goal is to understand how these types store and share references, and how operations on them affect program behavior as code and data structures become larger.\nAfter completing these examples, you should be able to:\n\nexplain the difference between identity and equality (is vs ==)\ndistinguish rebinding from in-place mutation and predict when aliasing causes a change to appear in more than one place\nuse list operations shown in the reading (including slice assignment and nested list construction) and predict when they modify an existing list\ndescribe key dictionary behaviors emphasized in the reading: insertion order, safe key access, and controlled updates\nuse sets for uniqueness and understand why set elements must be hashable\nexplain why tuples are used for fixed groupings and why item assignment is not allowed\ncopy nested structures intentionally by choosing between a shallow copy and a deep copy\nread and write a text file using pathlib.Path (read_text() and write_text())"
  },
  {
    "objectID": "assignments/week-03/week-3-demo.html#part-1-names-objects-and-references",
    "href": "assignments/week-03/week-3-demo.html#part-1-names-objects-and-references",
    "title": "CMSC 1236 — Week 3 Demo",
    "section": "Part 1: Names, objects, and references",
    "text": "Part 1: Names, objects, and references\nIn Python, a variable is a name that refers to an object. An object is a value stored in memory (for example, a list, a dictionary, an integer, or a string). When a name refers to an object, the name is said to be bound to that object.\nThis model is a basic part of programming in Python. It explains how changes to lists and dictionaries propagate through a program, and it helps you predict what happens when the same object is reused in more than one place. It also applies when a value is passed into a function, meaning the object is provided to a function as an argument so the function can use it. If the argument is a mutable object (an object whose contents can be changed after it is created) and the function mutates it, the change is visible after the function call because the same object is being used.\nPython’s built-in collection types (lists, dictionaries, sets, and tuples) store references to objects rather than copying them. As a result, the same object can be reached through more than one name.\nTwo operations are used throughout Python programs, and they are easy to confuse because both can occur after an assignment statement. The difference is what changes:\n\nrebinding changes which object a name refers to; the original object is unchanged\nmutation changes the contents of an existing object; any name that refers to that object will observe the change\n\nBecause Python programs frequently reuse objects through multiple names (intentionally or unintentionally), it is important to distinguish “same object” from “same value” so you can predict when a change will affect more than one variable. Two comparison operators are used for that purpose:\n\nis tests identity: whether two names refer to the same object in memory\n== tests equality: whether two objects have the same value\n\nThe following two examples establish the difference between identity and equality for collection objects.\n\nExample 1: Two names referring to the same object\nThis first example shows what it means for two names to refer to the same object. The output will confirm that a is b is true (same object) and a == b is also true (same contents).\n\na = [1, 2, 3]\nb = a\nprint(\"a =\", a)\nprint(\"b =\", b)\nprint(\"a is b =\", a is b)\nprint(\"a == b =\", a == b)\n\na = [1, 2, 3]\nb = [1, 2, 3]\na is b = True\na == b = True\n\n\nExplanation:\n\na = [1, 2, 3] creates a list object containing the integers 1, 2, and 3, and assigns the name a to refer to that list.\nb = a assigns the name b to refer to the same list object as a. No new list is created.\nprint(\"a =\", a) prints the label a = followed by the current value of a (the list object that a refers to).\nprint(\"b =\", b) prints the label b = followed by the current value of b (the same list object, since b refers to the same object as a).\nprint(\"a is b =\", a is b) prints the label a is b = followed by the result of the identity test a is b. This is True here because a and b refer to the same object in memory.\nprint(\"a == b =\", a == b) prints the label a == b = followed by the result of the equality test a == b. This is True here because the two values have the same contents (and in this case they are the same list object).\n\n\n\nExample 2: Different objects with the same value\nThis example shows that two different list objects can still be equal in value. The key observation is that x is y is false because two separate list objects are created, while x == y is true because the contents of the two lists match.\n\nx = [1, 2]\ny = [1, 2]\n\nprint(\"x =\", x)\nprint(\"y =\", y)\nprint(\"x is y =\", x is y)\nprint(\"x == y =\", x == y)\n\nx = [1, 2]\ny = [1, 2]\nx is y = False\nx == y = True\n\n\nExplanation:\n\nx = [1, 2] creates a list object containing the integers 1 and 2, and assigns the name x to refer to that list.\ny = [1, 2] creates a second list object containing the integers 1 and 2, and assigns the name y to refer to that second list. Even though the contents match, this is a different object in memory from the one referenced by x.\nprint(\"x =\", x) prints the label x = followed by the current value of x (the list object that x refers to).\nprint(\"y =\", y) prints the label y = followed by the current value of y (the list object that y refers to).\nprint(\"x is y =\", x is y) prints the label x is y = followed by the result of the identity test x is y. This is False because x and y refer to different list objects in memory.\nprint(\"x == y =\", x == y) prints the label x == y = followed by the result of the equality test x == y. This is True because the two lists contain the same values in the same order."
  },
  {
    "objectID": "assignments/week-03/week-3-demo.html#part-2-rebinding-vs-in-place-mutation-lists",
    "href": "assignments/week-03/week-3-demo.html#part-2-rebinding-vs-in-place-mutation-lists",
    "title": "CMSC 1236 — Week 3 Demo",
    "section": "Part 2) Rebinding vs in-place mutation (lists)",
    "text": "Part 2) Rebinding vs in-place mutation (lists)\nLists are mutable sequence objects, which means their contents can be changed after they are created. When lists are used in a program, two different kinds of changes are common:\n\na name can be reassigned to refer to a different list (rebinding)\nan existing list can be changed directly (in-place mutation)\n\nThis distinction matters because it affects whether a change is visible in other parts of a program. If two names refer to the same list object, then an in-place change is observed through both names. If a name is rebound to a new list object, other names that still refer to the original list are unaffected.\nThe following examples use two names (nums and alias) that initially refer to the same list so that the difference between rebinding and mutation is visible in the output.\n\nExample 1: Rebinding creates a new list\nIn this example, nums = nums + [40] produces a new list object and assigns nums to refer to that new list. The name alias continues to refer to the original list.\nBeginner-friendly version:\n\nnums = [10, 20, 30]\nalias = nums\n\nnums = nums + [40]\n\nprint(\"nums =\", nums)\nprint(\"alias =\", alias)\nprint(\"nums is alias =\", nums is alias)\n\nnums = [10, 20, 30, 40]\nalias = [10, 20, 30]\nnums is alias = False\n\n\nExplanation:\n\nnums = [10, 20, 30] creates a list object containing 10, 20, and 30, and assigns the name nums to refer to it.\nalias = nums assigns the name alias to refer to the same list object as nums. No new list is created.\nnums = nums + [40] uses + to create a new list that contains the items from the original nums list followed by 40. After the new list is created, nums is rebound so it refers to the new list object. The original list object is not changed in place, so alias still refers to the original list.\nprint(\"nums =\", nums) prints the new list that nums now refers to.\nprint(\"alias =\", alias) prints the original list that alias still refers to.\nprint(\"nums is alias =\", nums is alias) prints whether nums and alias refer to the same list object. This is False because nums was rebound to a different list.\n\n\n\nExample 2: In-place mutation changes the existing list\nIn this example, nums += [40] changes the existing list object in place. Because alias refers to the same list object, alias reflects the change as well.\nBeginner-friendly version:\n\nnums = [10, 20, 30]\nalias = nums\n\nnums += [40]\n\nprint(\"nums =\", nums)\nprint(\"alias =\", alias)\nprint(\"nums is alias =\", nums is alias)\n\nnums = [10, 20, 30, 40]\nalias = [10, 20, 30, 40]\nnums is alias = True\n\n\nExplanation:\n\nnums = [10, 20, 30] creates a list object containing 10, 20, and 30, and assigns the name nums to refer to it.\nalias = nums assigns the name alias to refer to the same list object as nums. No new list is created.\nnums += [40] modifies the existing list object in place by adding 40 to the end. The name nums still refers to the same list object as before.\nprint(\"nums =\", nums) prints the modified list.\nprint(\"alias =\", alias) prints the same modified list, because alias refers to the same object.\nprint(\"nums is alias =\", nums is alias) prints whether nums and alias refer to the same list object. This is True because the list was mutated in place rather than replaced."
  },
  {
    "objectID": "assignments/week-03/week-3-demo.html#lists-sequence-type-slice-assignment-and-nested-list-construction",
    "href": "assignments/week-03/week-3-demo.html#lists-sequence-type-slice-assignment-and-nested-list-construction",
    "title": "CMSC 1236 — Week 3 Demo",
    "section": "3) Lists (sequence type): slice assignment and nested list construction",
    "text": "3) Lists (sequence type): slice assignment and nested list construction\nThis section focuses on two list operations that are easy to use correctly in small examples, but can cause confusion in larger programs if the effect on the existing list object is not understood. First, lists support slice assignment, which replaces part of a list by assigning to a slice. A slice is a range of positions written as start:stop (the stop position is not included). This matters because slice assignment changes the existing list in place rather than creating a new list, so the change is visible anywhere that same list is referenced.\nSecond, lists support repetition with *. When the repeated item is itself a mutable object (such as a list), repetition can produce a nested structure in which multiple positions refer to the same inner object. This matters because changing one inner list then appears to change multiple “rows” at once.\nThe examples in this section demonstrate slice assignment as an in-place change, and they contrast two ways to build a list of lists: one that repeats references and one that creates independent inner lists.\n\nExample 1: Slice assignment modifies a list in place\nSlice assignment replaces part of a list without creating a new list object. The key observation is that the list referenced by data changes, but data continues to refer to the same list object.\nBeginner-friendly version:\n\ndata = [0, 1, 2, 3, 4, 5]\n\nprint(\"before:\", data)\n\ndata[2:5] = [\"a\", \"b\"]\n\nprint(\"after: \", data)\n\nbefore: [0, 1, 2, 3, 4, 5]\nafter:  [0, 1, 'a', 'b', 5]\n\n\nExplanation:\n\ndata = [0, 1, 2, 3, 4, 5] creates a list object containing six integers and assigns the name data to refer to it.\nprint(\"before:\", data) prints the list before any changes are made.\ndata[2:5] = [\"a\", \"b\"] replaces the slice of data from index 2 up to (but not including) index 5 with the two elements \"a\" and \"b\". This operation changes the existing list object in place.\nprint(\"after: \", data) prints the modified list so the effect of the slice assignment is visible.\n\n\n\nExample 2: Nested lists and repeated references (* repetition)\nList repetition with * repeats references when the repeated element is a mutable object (such as a list). The key observation is that changing one inner list changes every “row” when all rows refer to the same inner list object.\nBeginner-friendly version (repeated references):\n\nrow = [0, 0]\ngrid_bad = [row] * 3\n\nprint(\"before:\", grid_bad)\n\ngrid_bad[0][0] = 99\n\nprint(\"after: \", grid_bad)\n\nbefore: [[0, 0], [0, 0], [0, 0]]\nafter:  [[99, 0], [99, 0], [99, 0]]\n\n\nExplanation:\n\nrow = [0, 0] creates a list object containing two zeros and assigns the name row to refer to it.\ngrid_bad = [row] * 3 creates a new outer list with three elements, but each element is a reference to the same inner list object referenced by row. No independent inner lists are created.\nprint(\"before:\", grid_bad) prints the nested list structure before mutation.\ngrid_bad[0][0] = 99 changes the first element of the first inner list to 99. Because all three “rows” refer to the same inner list object, the change appears in every row.\nprint(\"after: \", grid_bad) prints the nested list structure after mutation to show the repeated-reference effect.\n\n\n\nExample 3: Nested lists created as independent inner lists (recommended construction)\nA common pattern for building nested lists is to construct each inner list independently so that mutating one row does not affect the others.\nBeginner-friendly version (independent inner lists):\n\ngrid_ok = [[0, 0] for _ in range(3)]\n\nprint(\"before:\", grid_ok)\n\ngrid_ok[0][0] = 99\n\nprint(\"after: \", grid_ok)\n\nbefore: [[0, 0], [0, 0], [0, 0]]\nafter:  [[99, 0], [0, 0], [0, 0]]\n\n\nExplanation:\n\ngrid_ok = [[0, 0] for _ in range(3)] builds a new outer list by running the expression [0, 0] three times, producing three separate inner list objects. The name grid_ok refers to the resulting nested list.\nprint(\"before:\", grid_ok) prints the nested list structure before mutation.\ngrid_ok[0][0] = 99 changes the first element of the first inner list to 99. Because each row is a different inner list object, the change affects only the first row.\nprint(\"after: \", grid_ok) prints the nested list structure after mutation to show that only one row changed."
  },
  {
    "objectID": "assignments/week-03/week-3-demo.html#dictionaries-mapping-type-insertion-order-safe-access-and-controlled-updates",
    "href": "assignments/week-03/week-3-demo.html#dictionaries-mapping-type-insertion-order-safe-access-and-controlled-updates",
    "title": "CMSC 1236 — Week 3 Demo",
    "section": "4) Dictionaries (mapping type): insertion order, safe access, and controlled updates",
    "text": "4) Dictionaries (mapping type): insertion order, safe access, and controlled updates\nThere are four dictionary behaviors in this unit that are important for writing predictable programs with mappings.\nA dictionary is the built-in mapping type: it stores values by key rather than by position. Because dictionaries are used to represent configuration, lookup tables, and structured records, it is important to understand how key order behaves, how to access keys safely, and how to update dictionaries without accidentally changing an object that other parts of a program still rely on.\nThe examples that follow demonstrate:\n\ninsertion order during iteration (order of insertion, not sorting),\nsafe access using membership tests and get when keys may be missing,\ncontrolled updates using copy and update to preserve an original mapping,\nkey-view comparisons using set operations to reason about which keys match or differ.\n\n\nExample 1: Insertion order (iteration is not sorting)\nThis example shows that dictionaries preserve the order in which keys were inserted. The key observation is that the dictionary’s key order matches insertion order, not alphabetical order.\nBeginner-friendly version:\n\nd = {\"b\": 2, \"a\": 1, \"c\": 3}\n\nprint(\"dictionary =\", d)\nprint(\"keys in iteration order =\", list(d.keys()))\n\ndictionary = {'b': 2, 'a': 1, 'c': 3}\nkeys in iteration order = ['b', 'a', 'c']\n\n\nExplanation:\n\nd = {\"b\": 2, \"a\": 1, \"c\": 3} creates a dictionary with three key-value pairs and assigns the name d to refer to it.\nprint(\"dictionary =\", d) prints the dictionary so the insertion order is visible in the displayed representation.\nprint(\"keys in iteration order =\", list(d.keys())) converts the dictionary’s keys view to a list and prints it. The result reflects insertion order.\n\n\n\nExample 2: Safe access with membership tests and get\nThis example shows two standard ways to handle keys that may or may not exist. The key observation is that membership tests report whether a key is present, and get returns a default value instead of raising an error when a key is missing.\nBeginner-friendly version:\n\nconfig = {\"mode\": \"test\"}\n\nprint(\"config =\", config)\n\nprint(\"'mode' in config =\", \"mode\" in config)\nprint(\"'timeout' in config =\", \"timeout\" in config)\n\nprint(\"config.get('mode') =\", config.get(\"mode\"))\nprint(\"config.get('timeout', 30) =\", config.get(\"timeout\", 30))\n\nconfig = {'mode': 'test'}\n'mode' in config = True\n'timeout' in config = False\nconfig.get('mode') = test\nconfig.get('timeout', 30) = 30\n\n\nExplanation:\n\nconfig = {\"mode\": \"test\"} creates a dictionary with one key-value pair and assigns config to refer to it.\nprint(\"config =\", config) prints the dictionary.\nprint(\"'mode' in config =\", \"mode\" in config) tests whether the key \"mode\" is present in the dictionary.\nprint(\"'timeout' in config =\", \"timeout\" in config) tests whether the key \"timeout\" is present in the dictionary.\nprint(\"config.get('mode') =\", config.get(\"mode\")) retrieves the value for \"mode\". Because the key exists, the value is returned.\nprint(\"config.get('timeout', 30) =\", config.get(\"timeout\", 30)) attempts to retrieve the value for \"timeout\". Because the key does not exist, the default value 30 is returned instead.\n\n\n\nExample 3: Controlled updates using copy and update\nThis example shows how to combine a base dictionary with an override dictionary without modifying the original. The key observation is that copy creates a new dictionary object, and update mutates that new dictionary by applying key-value pairs from another dictionary.\nBeginner-friendly version:\n\nbase = {\"host\": \"localhost\", \"port\": 8000}\noverride = {\"port\": 9000}\n\nmerged = base.copy()\nmerged.update(override)\n\nprint(\"base =\", base)\nprint(\"override =\", override)\nprint(\"merged =\", merged)\n\nbase = {'host': 'localhost', 'port': 8000}\noverride = {'port': 9000}\nmerged = {'host': 'localhost', 'port': 9000}\n\n\nExplanation:\n\nbase = {\"host\": \"localhost\", \"port\": 8000} creates a dictionary containing default settings.\noverride = {\"port\": 9000} creates a second dictionary containing settings that should replace or extend defaults.\nmerged = base.copy() creates a new dictionary object with the same key-value pairs as base and assigns merged to refer to it.\nmerged.update(override) modifies merged in place by applying key-value pairs from override. In this case, the \"port\" key is overwritten with 9000.\nThe three print statements display base, override, and merged so that it is clear the original base dictionary was not changed.\n\n\n\nExample 4: Dictionary key views for comparisons\nThis example shows that keys() returns a view of keys that can be used in set operations. The key observation is that intersection identifies keys present in both dictionaries, and difference identifies keys present in one dictionary but not the other.\nBeginner-friendly version:\n\na = {\"x\": 1, \"y\": 2, \"z\": 3}\nb = {\"y\": 20, \"z\": 30, \"w\": 40}\n\ncommon = a.keys() & b.keys()\nonly_in_a = a.keys() - b.keys()\n\nprint(\"a keys =\", list(a.keys()))\nprint(\"b keys =\", list(b.keys()))\nprint(\"keys in both =\", common)\nprint(\"keys only in a =\", only_in_a)\n\na keys = ['x', 'y', 'z']\nb keys = ['y', 'z', 'w']\nkeys in both = {'y', 'z'}\nkeys only in a = {'x'}\n\n\nExplanation:\n\na = {\"x\": 1, \"y\": 2, \"z\": 3} creates a dictionary with three keys and assigns a to refer to it.\nb = {\"y\": 20, \"z\": 30, \"w\": 40} creates a second dictionary with an overlapping set of keys and assigns b to refer to it.\ncommon = a.keys() & b.keys() computes the intersection of the two key views, producing the set of keys that appear in both dictionaries.\nonly_in_a = a.keys() - b.keys() computes the difference, producing the set of keys that appear in a but not in b.\nThe print statements display the keys and the computed comparisons."
  },
  {
    "objectID": "assignments/week-03/week-3-demo.html#set-types-uniqueness-and-hashability",
    "href": "assignments/week-03/week-3-demo.html#set-types-uniqueness-and-hashability",
    "title": "CMSC 1236 — Week 3 Demo",
    "section": "5) Set types: uniqueness and hashability",
    "text": "5) Set types: uniqueness and hashability\nA set is a built-in collection type used to represent a group of unique values. Unlike lists and tuples, sets do not keep items in a positional order, and duplicate values are automatically removed.\nSets are useful when the question is “is this value present?” or when a collection needs to be reduced to distinct values. To support fast membership testing, set elements must be hashable, which requires that an element’s value not change in a way that would affect its hash. For that reason, mutable objects such as lists cannot be set elements.\nThe examples that follow demonstrate two points: constructing a set removes duplicates from an input sequence, and attempting to place an unhashable value (such as a list) into a set results in an error.\n\nExample 1: De-duplication by constructing a set\nThis example shows that building a set from a list removes duplicate values. The key observation is that repeated items from the list appear only once in the set.\nBeginner-friendly version:\n\nitems = [\"apple\", \"apple\", \"pear\", \"banana\", \"banana\"]\n\nunique_items = set(items)\n\nprint(\"original list =\", items)\nprint(\"set (unique values) =\", unique_items)\n\noriginal list = ['apple', 'apple', 'pear', 'banana', 'banana']\nset (unique values) = {'pear', 'banana', 'apple'}\n\n\nExplanation:\n\nitems = [\"apple\", \"apple\", \"pear\", \"banana\", \"banana\"] creates a list that contains repeated strings and assigns the name items to refer to it.\nunique_items = set(items) constructs a set from the list. Because sets store only distinct values, duplicates are removed.\nprint(\"original list =\", items) prints the original list so the duplicates are visible.\nprint(\"set (unique values) =\", unique_items) prints the set so the unique values are visible.\n\n\n\nExample 2: Hashability requirement (what can be an element of a set)\nThis example shows that lists cannot be elements of a set. The key observation is that Python raises a TypeError because lists are mutable and therefore not hashable.\nBeginner-friendly version:\n\ntry:\n    bad = {[1, 2], [3, 4]}\nexcept TypeError as e:\n    print(\"error:\", e)\n\nerror: cannot use 'list' as a set element (unhashable type: 'list')\n\n\nExplanation:\n\nThe try block attempts to create a set containing two list objects: [1, 2] and [3, 4].\nPython raises a TypeError because list objects are mutable and cannot be used as set elements.\nThe except TypeError as e block catches the error and prints the message so the reason for the failure is visible."
  },
  {
    "objectID": "assignments/week-03/week-3-demo.html#tuples-sequence-type-immutable-record-style-grouping",
    "href": "assignments/week-03/week-3-demo.html#tuples-sequence-type-immutable-record-style-grouping",
    "title": "CMSC 1236 — Week 3 Demo",
    "section": "6) Tuples (sequence type, immutable): record-style grouping",
    "text": "6) Tuples (sequence type, immutable): record-style grouping\nA tuple is a built-in sequence type, which means it holds an ordered collection of items that can be accessed by position (index). Tuples are similar to lists in how they are written and indexed, but they differ in one important way.\nA list is mutable, meaning its contents can be changed after it is created. A tuple is immutable, meaning that after a tuple is created, the individual items inside it cannot be replaced using assignment. This makes tuples useful for grouping a fixed set of related values into a single object, where each position has a stable meaning (for example, a first name, last name, and year).\nThe examples that follow demonstrate two points: tuple items can be accessed by index like other sequences, and attempting to assign to a tuple element results in an error because tuples do not support item assignment.\n\nExample 1: Accessing tuple items by index\nThis example shows that tuples support indexing. The key observation is that the first and last items can be accessed using 0 and -1, just as with lists.\nBeginner-friendly version:\n\nrecord = (\"Ada\", \"Lovelace\", 1815)\n\nprint(\"record =\", record)\nprint(\"first item =\", record[0])\nprint(\"last item =\", record[-1])\n\nrecord = ('Ada', 'Lovelace', 1815)\nfirst item = Ada\nlast item = 1815\n\n\nExplanation:\n\nrecord = (\"Ada\", \"Lovelace\", 1815) creates a tuple containing three items and assigns the name record to refer to it.\nprint(\"record =\", record) prints the tuple so its contents are visible.\nprint(\"first item =\", record[0]) prints the first item in the tuple (index 0).\nprint(\"last item =\", record[-1]) prints the last item in the tuple (index -1 counts from the end).\n\n\n\nExample 2: Tuples do not allow item assignment (immutability)\nThis example shows that tuple items cannot be reassigned. The key observation is that Python raises a TypeError when an assignment to a tuple element is attempted.\nBeginner-friendly version:\n\nrecord = (\"Ada\", \"Lovelace\", 1815)\n\ntry:\n    record[0] = \"ADA\"\nexcept TypeError as e:\n    print(\"error:\", e)\n\nerror: 'tuple' object does not support item assignment\n\n\nExplanation:\n\nrecord = (\"Ada\", \"Lovelace\", 1815) creates a tuple containing three items and assigns record to refer to it.\nThe try block attempts to assign a new value to record[0].\nPython raises a TypeError because tuples are immutable and do not support item assignment.\nThe except TypeError as e block catches the error and prints the message."
  },
  {
    "objectID": "assignments/week-03/week-3-demo.html#copying-nested-collection-objects-shallow-vs-deep",
    "href": "assignments/week-03/week-3-demo.html#copying-nested-collection-objects-shallow-vs-deep",
    "title": "CMSC 1236 — Week 3 Demo",
    "section": "7) Copying nested collection objects (shallow vs deep)",
    "text": "7) Copying nested collection objects (shallow vs deep)\nWhen a collection contains other collection objects, the structure is nested. A nested structure is one where an outer object (such as a list) contains inner objects (such as other lists). When the inner objects are mutable, changes to an inner object can affect more than one variable if those variables share references to the same inner object.\nCopying matters because programs often need a “starting version” of data and a “working version” of data at the same time. For example, a program might keep an original configuration, menu, or table of values unchanged while also building a modified version for output or for the next step in a computation. If the copy shares inner objects with the original, then changing the working version can unexpectedly change the original as well.\nTwo terms are used in this section:\n\nshallow copy: creates a new outer collection, but the inner objects are shared\ndeep copy: creates a new outer collection and also creates copies of nested objects\n\nThe examples that follow show the practical difference by mutating an inner list and observing whether the original structure changes.\n\nExample 1: Shallow copy shares inner lists\nThis example shows that slicing a nested list (nested[:]) creates a new outer list but does not copy the inner lists. The key observation is that changing an inner list through the shallow copy also changes the original.\nBeginner-friendly version:\n\nnested = [[1, 2], [3, 4]]\nshallow = nested[:]\n\nprint(\"nested before =\", nested)\nprint(\"shallow before =\", shallow)\n\nshallow[0].append(999)\n\nprint(\"nested after  =\", nested)\nprint(\"shallow after =\", shallow)\nprint(\"nested is shallow =\", nested is shallow)\nprint(\"nested[0] is shallow[0] =\", nested[0] is shallow[0])\n\nnested before = [[1, 2], [3, 4]]\nshallow before = [[1, 2], [3, 4]]\nnested after  = [[1, 2, 999], [3, 4]]\nshallow after = [[1, 2, 999], [3, 4]]\nnested is shallow = False\nnested[0] is shallow[0] = True\n\n\nExplanation:\n\nnested = [[1, 2], [3, 4]] creates an outer list that contains two inner lists, and assigns nested to refer to it.\nshallow = nested[:] creates a new outer list containing the same two inner list objects, and assigns shallow to refer to it. The inner lists are not copied.\nThe first two print statements display nested and shallow before any changes.\nshallow[0].append(999) modifies the first inner list in place by appending 999. Because nested[0] and shallow[0] refer to the same inner list object, the change appears in both nested and shallow.\nThe next two print statements display nested and shallow after the mutation.\nprint(\"nested is shallow =\", nested is shallow) shows that the outer lists are different objects.\nprint(\"nested[0] is shallow[0] =\", nested[0] is shallow[0]) shows that the first inner list object is shared.\n\n\n\nExample 2: Deep copy creates independent nested objects\nThis example shows that a deep copy duplicates the nested structure. The key observation is that changing an inner list in the deep copy does not change the original.\nBeginner-friendly version:\n\nimport copy\n\nnested = [[1, 2], [3, 4]]\ndeep = copy.deepcopy(nested)\n\nprint(\"nested before =\", nested)\nprint(\"deep before   =\", deep)\n\ndeep[0].append(999)\n\nprint(\"nested after  =\", nested)\nprint(\"deep after    =\", deep)\nprint(\"nested is deep =\", nested is deep)\nprint(\"nested[0] is deep[0] =\", nested[0] is deep[0])\n\nnested before = [[1, 2], [3, 4]]\ndeep before   = [[1, 2], [3, 4]]\nnested after  = [[1, 2], [3, 4]]\ndeep after    = [[1, 2, 999], [3, 4]]\nnested is deep = False\nnested[0] is deep[0] = False\n\n\nExplanation:\n\nimport copy loads the copy module so that deepcopy can be used.\nnested = [[1, 2], [3, 4]] creates an outer list containing two inner lists and assigns nested to refer to it.\ndeep = copy.deepcopy(nested) creates a new outer list and also creates new inner list objects with the same contents, then assigns deep to refer to the copied structure.\nThe first two print statements display nested and deep before any changes.\ndeep[0].append(999) modifies the first inner list in the deep copy by appending 999.\nThe next two print statements display nested and deep after the mutation. nested is unchanged because the inner lists are not shared.\nprint(\"nested is deep =\", nested is deep) shows that the outer lists are different objects.\nprint(\"nested[0] is deep[0] =\", nested[0] is deep[0]) shows that the first inner list objects are different, confirming that the nested lists were copied."
  },
  {
    "objectID": "assignments/week-03/week-3-demo.html#file-access-with-pathlib.path-modern-interface",
    "href": "assignments/week-03/week-3-demo.html#file-access-with-pathlib.path-modern-interface",
    "title": "CMSC 1236 — Week 3 Demo",
    "section": "8) File access with pathlib.Path (modern interface)",
    "text": "8) File access with pathlib.Path (modern interface)\nBasic file handling using open() and a with block was introduced in CMSC 1203, and the textbook’s Chapter 9 presents that same approach as the standard, universal way to work with files in Python. This section does not re-teach that baseline.\nInstead, the focus here is a modern alternative interface that is widely used in current Python code: the pathlib module. This module is not covered in CMSC 1203 and it is not a topic in Learning Python Chapters 8–9, but it is a practical tool that builds directly on the same underlying file concepts.\nA pathlib.Path object represents a file path as an object rather than as a plain string. It can simplify common tasks such as reading and writing text and helps keep file-related code consistent and readable as programs grow.\nThe examples that follow demonstrate how to:\n\ncreate a Path object for a file,\nread an entire text file with read_text(),\nwrite text to a file with write_text(),\nand confirm the results by reading the file again.\n\n\nExample 1: File access with pathlib.Path\nIn a notebook, files are created in the notebook’s working directory. The working directory is the folder Python treats as the “current location” when you use a relative file name like demo_text.txt. If the file name does not include a folder path, it refers to a file in that current folder.\nThis example writes a text file first (so the file always exists), then reads it back.\n\nfrom pathlib import Path\n\npath = Path(\"demo_text.txt\")\n\npath.write_text(\"first line\\nsecond line\\nthird line\\n\")\n\ntext = path.read_text()\nprint(\"file contents:\\n\" + text)\n\npath.write_text(\"replacement line 1\\nreplacement line 2\\n\")\n\nupdated_text = path.read_text()\nprint(\"updated file contents:\\n\" + updated_text)\n\nfile contents:\nfirst line\nsecond line\nthird line\n\nupdated file contents:\nreplacement line 1\nreplacement line 2\n\n\n\nExplanation:\n\nfrom pathlib import Path imports the Path class from the pathlib module.\npath = Path(\"demo_text.txt\") creates a Path object representing a file named demo_text.txt in the current working directory.\npath.write_text(\"first line\\nsecond line\\nthird line\\n\") writes the given string to the file. If the file does not exist, it is created. If it already exists, its contents are replaced.\ntext = path.read_text() reads the entire file and returns it as a single string.\nprint(\"file contents:\\n\" + text) prints the contents that were read so the result is visible.\npath.write_text(\"replacement line 1\\nreplacement line 2\\n\") writes new text to the same file, replacing the previous contents.\nupdated_text = path.read_text() reads the file again after the update.\nprint(\"updated file contents:\\n\" + updated_text) prints the updated contents so the change is visible."
  },
  {
    "objectID": "assignments/week-03/week-3-demo.html#summary-of-key-points",
    "href": "assignments/week-03/week-3-demo.html#summary-of-key-points",
    "title": "CMSC 1236 — Week 3 Demo",
    "section": "Summary of key points",
    "text": "Summary of key points\n\nNames refer to objects; collection objects store references to other objects.\nis tests identity; == tests value equality.\nRebinding and mutation produce different effects.\nLists and dictionaries are mutable; tuples are immutable.\nSet types enforce uniqueness and require hashable elements.\nShallow copies share nested objects; deep copies replicate nested objects.\npathlib.Path provides a modern way to read and write text files."
  },
  {
    "objectID": "course/syllabus.html",
    "href": "course/syllabus.html",
    "title": "CMSC 1236 – Advanced Python Programming",
    "section": "",
    "text": "Instructor(s): Joseph Silman Office: Online\nE-mail: jsilman@sctcc.edu (PRIMARY COMMUNICATION METHOD) Phone: (320)308-6595\nOffice Hours: See Attached Course Schedule in D2L or on Course Page.\nCredits: 3 (Lecture 2; Lab 1)",
    "crumbs": [
      "Home",
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "course/syllabus.html#course-description",
    "href": "course/syllabus.html#course-description",
    "title": "CMSC 1236 – Advanced Python Programming",
    "section": "Course Description",
    "text": "Course Description\nThis course builds on the foundational Python skills from CMSC1203 Structured Programming Logic, introducing students to advanced Python techniques for developing robust standalone applications. The course guides students through advanced object-oriented programming (OOP), functional programming, array-based numerical computing, project structuring, unit testing, and debugging. Through hands-on practical programming exercises, students create functional Python applications, gaining skills for technical roles in programming, system design, and related fields. This course emphasizes a programming-focused approach, ensuring students develop advanced, real-world Python programming expertise applicable to modern technology applications.\nThis online class requires extensive use of your webcam",
    "crumbs": [
      "Home",
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "course/syllabus.html#course-outcomes",
    "href": "course/syllabus.html#course-outcomes",
    "title": "CMSC 1236 – Advanced Python Programming",
    "section": "Course Outcomes",
    "text": "Course Outcomes\n\nUpon completion of this course the student will:\n\nIdentify advanced object-oriented programming constructs, including multiple inheritance and abstract base classes used in software design.\nExplain the role of lambdas, generators, and decorators in optimizing Python code efficiency.\nImplement array-based numerical computations, including matrix operations, within a Python program.\nCompare dependency management and package structuring techniques for organizing modular software projects.\nAssess the impact of unit testing and debugging techniques on software reliability.\nIntegrate advanced error-handling and exception management strategies into Python programs.\nOptimize Python code to meet specific performance requirements for computational tasks.\nDesign a standalone Python application to address a real-world programming challenge.",
    "crumbs": [
      "Home",
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "course/syllabus.html#course-content",
    "href": "course/syllabus.html#course-content",
    "title": "CMSC 1236 – Advanced Python Programming",
    "section": "Course Content",
    "text": "Course Content\n\nAdvanced Classes and Object-Oriented Programming Foundations\nAdvanced Object-Oriented Programming Concepts\nFunctional Programming in Python\nNumerical Computing with NumPy\nPython Project Structuring and Build Tools\nUnit Testing and Debugging\nCapstone Standalone Python Project",
    "crumbs": [
      "Home",
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "course/syllabus.html#required-materials",
    "href": "course/syllabus.html#required-materials",
    "title": "CMSC 1236 – Advanced Python Programming",
    "section": "Required Materials",
    "text": "Required Materials\nLearning Python, 6th Edition : Mark Lutz\nFluent Python: Clear, Concise, and Effective Programming, 2nd Edition : Luciano Ramalho\nComputer running current OS that supports Microsoft Office\nWebcam Required\n*** STUDENTS ARE REQUIRED TO HAVE THEIR MATERIALS AT THE START OF THE COURSE***",
    "crumbs": [
      "Home",
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "course/syllabus.html#methods-of-instruction",
    "href": "course/syllabus.html#methods-of-instruction",
    "title": "CMSC 1236 – Advanced Python Programming",
    "section": "Methods of Instruction",
    "text": "Methods of Instruction\nStudent Presentation Problem Solving Internet\nCreative Projects Assigned Reading\nProject Critiques Labs Lecture\nFilm/Slides/Videos Demonstrations",
    "crumbs": [
      "Home",
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "course/syllabus.html#gradingevaluation",
    "href": "course/syllabus.html#gradingevaluation",
    "title": "CMSC 1236 – Advanced Python Programming",
    "section": "Grading/Evaluation",
    "text": "Grading/Evaluation\nTests, textbook problems, individual projects, video assignments, and performance will be graded. Grades will be updated in D2L and you are responsible for verifying that your grades are correct. Academic Progress reports will only be sent out to students earning a grade of a “D” or lower. Course Grades will be per the following criteria:\nA = 100 – 90%\nB = 89 – 80%\nC = 79 – 70%\nD = 69 – 60 %\nF = Below 60 %\nGrades are weighted as follows:\n\nLabs - 45%\nVideo Activities – 40%\nD2L Quizzes/Tests – 15%\n\nSome assignments will be based off a pass/fail criterion. Grading Rubrics will be assigned to most course activities. Some assignments are automatically graded. Activities may be assigned but not be graded, these are for self-review to prepare you for graded activities. ‘Proof’ files will be provided to you on occasion to help you identify any issues with your assignment. It is expected that you review these when you receive your rubric feedback. Extra credit assignments or additional assignments are not offered in this course.",
    "crumbs": [
      "Home",
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "course/syllabus.html#course-policiespractices",
    "href": "course/syllabus.html#course-policiespractices",
    "title": "CMSC 1236 – Advanced Python Programming",
    "section": "Course Policies/Practices",
    "text": "Course Policies/Practices\n\nAcademic Integrity\nAcademic integrity is highly valued at St. Cloud Technical & Community College and throughout higher education. Maintaining academic integrity is the responsibility of every member of the college community: faculty, staff, administrators and students. Academic integrity requires students to refrain from engaging in or tolerating acts including, but not limited to, submitting false academic records, cheating, plagiarizing, altering, forging, or misusing a college academic record; acquiring or using test materials without faculty permission; acting alone or in cooperation with another to falsify records or to obtain dishonest grades, honors, or awards.\nAny violation of the St. Cloud Technical & Community College’s Academic Integrity Policy S3.28 is considered a disciplinary offense and will be subject to the policies of this instructor, entrance into the Academic Integrity Database, and possible disciplinary action as outlined in the Academic Integrity Procedure S3.28.1. Students accused of academic dishonesty may appeal the decision. Students may review the Academic Integrity process and access the Academic Integrity Appeal Form at https://www.sctcc.edu/academic-integrity.\nClass policy for Academic Integrity Violations will result in a reduction of your grade.\nhttp://sctcc.edu/sites/default/files/policies/S3.24%20Complaint%20Grievance.pdf\n\n\nClassroom Behavior\nAttendance is a necessary part of this course. Refer to the attendance policy outlined later in the syllabus\nOnline discussions should be civilized and respectful to everyone and relevant to the topic we are discussing.\nDisruptive behavior on any communication platform will not be tolerated.\nYou are expected to do your own work unless otherwise directed. Cheating, plagiarism, and any other form of academic dishonesty will not be tolerated. Please refer to the Code of Student Conduct and Academic Integrity policy for details.\nAny indication of inebriation or being under the influence, and/or displaying of alcohol or use of paraphernalia that could be associated with drug usage during assignments/course activities will result in removal from the session and/or course. No smoking during any online sessions. My policy is to remove you from the course and leave it to you to file a grievance to return.\nMeaningful and constructive dialogue is encouraged, but this also requires a degree of mutual respect, willingness to listen, and tolerance of opposing points of view. Respect for individual differences and alternative viewpoints will always be expected in this course. One’s words and use of language should be temperate and within acceptable bounds of civility and decency.\nDisruptive behaviors, including excessive talking about off topic items, arriving late to the start of meetings or returning late from breaks, sleeping, reading, or watching media, or game playing is not permitted and will result in a grade penalty.\nExtreme disruptive behavior, fighting (verbally), using repetitive profanity, personal or physical threats or insults, and angry outbursts, will result in your removal from the course in accordance with policies and procedures outlined in the SCTCC’s Code of Student Conduct.\nIf a student’s disruptive behavior causes them to miss an assignment, they will not receive credit for that assignment. If a student has been sanctioned due to disruptive behavior, they waive the right to a warning on a second occurrence.\n\n\nData Privacy and Student Course Progress\nStudents are encouraged to take ownership over their academic progress and communicate with faculty directly for any questions or concerns regarding their coursework. I am reachable at my listed contact information and office hours on this syllabus and happy to discuss your progress with you.\nPer the College’s Student Data Practices policy, I am unable to share information about a student’s course progress to anyone other than the student, including third parties such as parents/guardians, unless a current Information Release is on file with the Records and Registration Office. Faculty are often unable to confirm if an Information Release is on file, so it is always preferred that the student speak with the faculty one-on-one.\nBecause of the items outlined above, should a third party contact me directly with a question or concern about your progress, I will defer my response to you and not the third party. Students shall also not invite third parties to attend class meetings (online), as this causes a disruption to the learning environment.\nIf a student would like their course progress information released to a third party, they may do so by contacting the Dean’s office to make a request for specific information to be shared with the third party.\n\n\nComputer Requirements\nA Computer meeting the program requirements and able to run multiple instances of Windows or Linux OS concurrently (using virtualization) is required for this class.\nComputer requirements are outlined here:\nhttps://www.sctcc.edu/degrees-programs/computer-programming\n\n\nD2L\nA fundamental understanding of D2L is required for this course as it is the primary method to communicate course schedules, grade information, and class news. It is the student’s responsibility to learn to navigate and find information on D2L. SCTCC does offer information sessions on this tool.\n\n\nAttendance/Participation:\nAttendance is expected and monitored. You are responsible for monitoring your attendance and your absence count.\nAttendance will be determined by up to two contributing factors, logging into your D2L Brightspace course, and submission of weekly assignments. Failure to log into class and/or submit assignments for a week will result in an absence. Failure to log into class during a week where an assignment is not due and is not a scheduled holiday/spring break week will result in an absence. I will check logins and assignment submission for the previous week every Monday.\nYou must log into your online class and complete an activity by 11:30 PM on the first Wednesday of the first week of class. Failure to log in will result in being dropped from the course.\nMissing two consecutive weeks of class will result in being dropped from the course.\nMissing two total weeks of class (non-consecutive and any combination of unexcused/excused) will result in a reduction of one letter grade (10% of total points). Missing three total weeks of class will result in an additional reduction of a letter grade. Any absence over three will result in a further reduction of a letter grade for each occurrence. Classes I teach are considered independent of each other with respect to attendance. You may meet attendance requirements in one of my classes but fail attendance requirements in another class.\n\n\nTesting:\nD2L tests are electronic quizzes. These may be scheduled ahead of time or given without warning. If a D2L test is password protected, sharing passwords with another student will constitute an integrity violation.\nTests are not restricted to a specific day for this course but must be completed by the assignment due date as scheduled. You may have multiple attempts at an Online D2L quiz. Time for each question is normally 45 seconds per question. If multiple attempts are allowed, you must score greater than 60% on your first attempt to be allowed a second attempt and you must score greater than an 80% on your second attempt to be allowed a third attempt (if there is a third attempt). If you exceed the time limit on the quiz, the grading engine will mark the test as a 0 and will not allow any further work on your quiz. Always be aware of the time remaining on your quiz. You may not leave a quiz once you start it.\nNote on auto generated D2L Tests: You may not be able to backtrack through the questions on a D2L quiz. The Next Page and Submit Button are close to each other on the test page. It is possible to Submit a quiz inadvertently if you are not paying attention so ensure that you are reading the popup messages.\nTests and quizzes cannot be made up.\n\n\nSchedule\nSubject to change based on instructor and class needs.\n\n\nAssignments/Projects\nAll assignments must be turned in by the due date. Due dates will be announced during class and posted on D2L . Late assignments will not be accepted. A late assignment is any assignment that is not in the dropbox by the due/end date. Sometimes assignments will consist of two parts, a video submission, and a file submission. Missing either portion of the assignment will make the assignment ineligible for grading. Video assignments that cannot be accessed by the instructor at the time of grading will also not be accepted. All projects and assignments should be archived and kept. Any group work assigned is also ineligible for makeup so make sure that you are a responsible, considerate groupmate.\nTypes of assignments you may encounter in this course:\nWeekly practice assignments – are based on the week’s topics. You will normally receive 5 – 7 days to complete these types of assignment.\nProjects – are longer assignments that are bigger in scope than a practice assignment and usually have a timeline with concrete checkpoints. These assignments may be done in a group setting or individually depending on the project.\nVideo Assignments – are assignments in which you will use your webcam and record your desktop to complete a specific activity. Some video assignments are group-based activities. Ensure that you review the assignment and the assignment rubric for specific instructions.\n\n\nDress\nStudents are expected to dress in a manner that is considerate of their classmates and the instructor for any online video assignments.",
    "crumbs": [
      "Home",
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "course/syllabus.html#standards-for-materials-submitted",
    "href": "course/syllabus.html#standards-for-materials-submitted",
    "title": "CMSC 1236 – Advanced Python Programming",
    "section": "Standards for Materials Submitted",
    "text": "Standards for Materials Submitted\nSpecific standards for submitting assignments will be outlined by the instructor in the assignment instructions. Any assignment that does not follow these standards will not be accepted or subject to a significant grade penalty, this includes not submitting files in the correct file format and/or misnaming the file. If you have a question on a file submission, please ensure that you contact the instructor before the due date.\n\nStudent Email\nStudents will be expected to use email as the primary method of communication with the instructor. Students must use their college email account for all email communication with the instructor. Assignments will not be accepted via email. All students must abide by the following requirements:\n\nIf the subject line is missing, your email will not be accepted. The subject line MUST have your course name and course section/class time.\nStudents will check their email at least once per day.\nStudents will read all emails and attachments sent by the instructor.\nAny attachments submitted via email must pertain to the course.\n\nEmail communication is encouraged, however only administrative items will be answered on the night homework is due. An example of an administrative item is informing me of the birth of a child. Technical questions regarding homework will not be addressed. The purpose behind this policy is to limit procrastination.\nExpect email to be answered by the end of the next business day. Email sent on Friday will be answered the following Monday.",
    "crumbs": [
      "Home",
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "course/syllabus.html#student-responsibilitiescontributions",
    "href": "course/syllabus.html#student-responsibilitiescontributions",
    "title": "CMSC 1236 – Advanced Python Programming",
    "section": "Student Responsibilities/Contributions",
    "text": "Student Responsibilities/Contributions\n\nAttendance and participation is crucial to succeed in this class.\nEvery student will be required to produce projects based on professional standard for the industry.\nEvery student is expected to turn in all work as assigned.\nEvery student is expected to work cooperatively with classmates and the instructor.",
    "crumbs": [
      "Home",
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "course/syllabus.html#statement-of-accomodations",
    "href": "course/syllabus.html#statement-of-accomodations",
    "title": "CMSC 1236 – Advanced Python Programming",
    "section": "Statement of Accomodations",
    "text": "Statement of Accomodations\nSt. Cloud Technical & Community College is committed to supporting students with disabilities in obtaining, understanding, and advocating for equitable and inclusive access in all aspects of their education and campus life. It is the role of Accessibility Services to provide and/or arrange reasonable accommodations to qualified students who have a disability (or have acquired a disability) during any point of their tenure at SCTCC. Accommodations are established through collaboration between students, Accessibility Services, faculty, and staff to empower students to pursue their academic goals free from barriers while upholding the integrity of the academic experience.\nDisabilities take on several forms including but not limited to mental health, cognitive, learning, behavioral, chronic health/systemic, and physical.\nIf you have a disability (or think you may have a disability) contact Accessibility Services at 320-308-5064 or acc@sctcc.edu to establish an accommodation plan.\nIt is the responsibility of the student requesting accommodations to provide their instructor with their accommodation plan via email. It is encouraged that students with approved accommodations connect with their instructor as soon as they are able in order to proactively discuss how reasonable accommodation will be implemented in class and/or to address any concerns regarding emergency procedures. Students may submit their plan to faculty at any time during the semester, but accommodations cannot be retroactively applied.\nMore information and guidelines are available at www.sctcc.edu/accessibility.\nThis syllabus is available in alternate formats upon request by contacting Accessibility Services at 320-308-5757, 1-800-222-1009, or acc@sctcc.edu. TTY users may call MN Relay Service at 711 to contact the college. Discrimination against individuals on the grounds of disability is prohibited.",
    "crumbs": [
      "Home",
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "course/syllabus.html#statement-of-diversity",
    "href": "course/syllabus.html#statement-of-diversity",
    "title": "CMSC 1236 – Advanced Python Programming",
    "section": "Statement of Diversity",
    "text": "Statement of Diversity\nThe entire class will benefit from the wealth of diversity brought by each individual, so students are asked to extend every courtesy and respect that they, in turn, would expect from the class.\nThis college is committed to creating a positive, supportive environment that welcomes diversity of opinions and ideas for students. There will be no tolerance of race discrimination/harassment, sexual discrimination/harassment, or discrimination/harassment based on age, disability, color, creed, national origin, religion, sexual orientation, marital status, status with regard to public assistance, or membership in a local commission.",
    "crumbs": [
      "Home",
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "course/syllabus.html#course-calendar",
    "href": "course/syllabus.html#course-calendar",
    "title": "CMSC 1236 – Advanced Python Programming",
    "section": "Course Calendar",
    "text": "Course Calendar\nSee News and Content page on D2L. The Instructor may make adjustments or changes. Notification will be given in class prior to change.\n\n\n\n\n\n\n\n\n\nWeek\nDates\nTopics\nReading\n\n\n\n\n1\nJan 12, 2026–Jan 18, 2026\nCourse environment + workflow (venv, Git, VS Code, run/submit). Start Virtual Pet v1 (menu loop skeleton, I/O patterns)\nLearning Python 6e Ch. 1–7 (2-week reading block begins)\n\n\n2\nJan 19, 2026–Jan 25, 2026\nFinish Virtual Pet v1 (Pet class + conditionals + validation/invalid input + pickle save/load)\nLearning Python 6e Ch. 1–7 (finish by end of Week 2)\n\n\n3\nJan 26, 2026–Feb 01, 2026\nCore containers for CLI apps (lists/dicts/tuples) + file/persistence concepts to support the pet project\nLearning Python 6e Ch. 8–9\n\n\n4\nFeb 02, 2026–Feb 08, 2026\nStatements + assignment mechanics (unpacking, multiple assignment), practical output/formatting habits\nLearning Python 6e Ch. 10–11\n\n\n5\nFeb 09, 2026–Feb 15, 2026\nControl flow upgrade: if + match + truthiness for clean CLI logic\nLearning Python 6e Ch. 12\n\n\n6\nFeb 16, 2026–Feb 22, 2026\nLoop patterns used in real programs (validation loops, enumerate, zip, loop-else)\nLearning Python 6e Ch. 13\n\n\n7\nFeb 23, 2026–Mar 01, 2026\nIteration & comprehensions as “muscle memory” tools (readability + correctness)\nLearning Python 6e Ch. 14\n\n\n8\nMar 02, 2026–Mar 08, 2026\nFunctions as structure: boundaries, scope model, and argument patterns (foundation for refactoring)\nLearning Python 6e Ch. 16–18\n\n\n9\nMar 09, 2026–Mar 15, 2026\nSpring Break (no due dates)\n—\n\n\n10\nMar 16, 2026–Mar 22, 2026\nFunction “level-up”: advanced function topics + comprehensions/generators as programming habits\nLearning Python 6e Ch. 19–20\n\n\n11\nMar 23, 2026–Mar 29, 2026\nReal-program organization + reliability: modules/packages/__main__ + exceptions/context managers (selected)\nLearning Python 6e Ch. 22–25 + 33–36 (selected)\n\n\n12\nMar 30, 2026–Apr 05, 2026\nPivot to Fluent Python: data model mindset, why “dunder methods” matter\nFluent Python 2e Ch. 1\n\n\n13\nApr 06, 2026–Apr 12, 2026\nFunctions as objects for cleaner architecture (dispatch tables, callbacks, command systems)\nFluent Python 2e Ch. 7\n\n\n14\nApr 13, 2026–Apr 19, 2026\nFinal project proposal week: scope, constraints, milestones, repo plan, feature choices\nTargeted review of FP Ch. 1 & 7 + LP modules/exceptions (as needed)\n\n\n15\nApr 20, 2026–Apr 26, 2026\nIterators/generators for logs + reporting; “event stream” thinking for CLI apps\nFluent Python 2e Ch. 17\n\n\n16\nApr 27, 2026–May 03, 2026\nFinal project build week (student-chosen standalone CLI app)\nTargeted reading as needed\n\n\n17\nMay 04, 2026–May 10, 2026\nFinal polish: edge cases, reliability, run instructions, demo readiness\nTargeted review as needed",
    "crumbs": [
      "Home",
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "shared/guides/cmsc-1217/week-02/cmsc-1217-chap-03-learning-resources.html",
    "href": "shared/guides/cmsc-1217/week-02/cmsc-1217-chap-03-learning-resources.html",
    "title": "Week 2: Chapter 3 Additional Reference Videos (Files, Parsing, Comprehensions, Lambda, Generators)",
    "section": "",
    "text": "Try / Except | Python (Tutorial)\nby Socratica — A focused explanation of what try and except actually do, and why this pattern is useful when you want to keep processing after one failure."
  },
  {
    "objectID": "shared/guides/cmsc-1217/week-02/cmsc-1217-chap-03-learning-resources.html#exceptions-and-safe-processing-tryexcept",
    "href": "shared/guides/cmsc-1217/week-02/cmsc-1217-chap-03-learning-resources.html#exceptions-and-safe-processing-tryexcept",
    "title": "Week 2: Chapter 3 Additional Reference Videos (Files, Parsing, Comprehensions, Lambda, Generators)",
    "section": "",
    "text": "Try / Except | Python (Tutorial)\nby Socratica — A focused explanation of what try and except actually do, and why this pattern is useful when you want to keep processing after one failure."
  },
  {
    "objectID": "shared/guides/cmsc-1217/week-02/cmsc-1217-chap-03-learning-resources.html#list-comprehensions-compact-build-a-new-list-loops",
    "href": "shared/guides/cmsc-1217/week-02/cmsc-1217-chap-03-learning-resources.html#list-comprehensions-compact-build-a-new-list-loops",
    "title": "Week 2: Chapter 3 Additional Reference Videos (Files, Parsing, Comprehensions, Lambda, Generators)",
    "section": "List comprehensions (compact “build a new list” loops)",
    "text": "List comprehensions (compact “build a new list” loops)\nLearn Python LIST COMPREHENSIONS in 10 minutes!\nby Bro Code — Quick overview of list comprehension syntax, comparing them to regular for loops with many clear examples.\n\nList Comprehensions | Python (Tutorial)\nby CS Dojo — List comprehension basics in Python - let’s go!\n\nPython Tutorial: List Comprehensions\nby Corey Schafer — A deeper walkthrough showing common patterns and how comprehensions relate to the equivalent loop form."
  },
  {
    "objectID": "shared/guides/cmsc-1217/week-02/cmsc-1217-chap-03-learning-resources.html#lambda-a-small-function-used-inline",
    "href": "shared/guides/cmsc-1217/week-02/cmsc-1217-chap-03-learning-resources.html#lambda-a-small-function-used-inline",
    "title": "Week 2: Chapter 3 Additional Reference Videos (Files, Parsing, Comprehensions, Lambda, Generators)",
    "section": "Lambda (a small function used inline)",
    "text": "Lambda (a small function used inline)\nLearn Python LAMBDA in 6 minutes!\nby Bro Code — Introduces lambda functions as short, anonymous functions and shows common use cases like sorting and mapping.\n\nPython Tutorial: Lambda Functions\nby Corey Schafer — Explains what a lambda is, when it’s useful, and how it connects to patterns like sorted(..., key=...) and max(..., key=...)."
  },
  {
    "objectID": "shared/guides/cmsc-1217/week-02/cmsc-1217-chap-03-learning-resources.html#generators-and-iteration-yield-streaming-one-row-at-a-time",
    "href": "shared/guides/cmsc-1217/week-02/cmsc-1217-chap-03-learning-resources.html#generators-and-iteration-yield-streaming-one-row-at-a-time",
    "title": "Week 2: Chapter 3 Additional Reference Videos (Files, Parsing, Comprehensions, Lambda, Generators)",
    "section": "Generators and iteration (yield, streaming one row at a time)",
    "text": "Generators and iteration (yield, streaming one row at a time)\nPython Generators Explained\nby Programming with Mosh — Clear, beginner-friendly explanation of generators, how they work, and why they’re useful for memory-efficient data processing.\n\nPython Tutorial: Generators - How to use them and the benefits you receive\nby Corey Schafer — A practical explanation of yield, how generator functions behave differently from normal functions, and what changes when you iterate over a generator."
  },
  {
    "objectID": "shared/guides/setup/environment-setup-guide-vscode.html",
    "href": "shared/guides/setup/environment-setup-guide-vscode.html",
    "title": "Week 1 — VSCode Setup and First Notebook (Windows)",
    "section": "",
    "text": "What you’re doing\nYou are going to open a Jupyter notebook in VS Code and run it successfully using the course Python environment.\n\n\n1) Open the course folder in VS Code\n\nOpen VS Code\nGo to File → Open Folder…\nOpen your course work folder (example: C:\\cmsc-1217\\)\n\n\n\n2) Install the extensions (if you don’t already have them)\nIn VS Code, install:\n\nPython (Microsoft)\nJupyter (Microsoft)\n\n\n\n3) Create the course Python environment and select it in VS Code (one-time)\n\n3A) Create the course environment folder\n\nCreate a folder on your C: drive named:\n\nC:\\cmsc-1217-env\\\n\n\n\n\n3B) Create the virtual environment (.venv)\n\nOpen Command Prompt (Windows search → type “Command Prompt”)\nRun:\n\ncd C:\\cmsc-1217-env\npython -m venv .venv\n\n\n3C) Activate the environment\nIn the same Command Prompt window, run:\nC:\\cmsc-1217-env\\.venv\\Scripts\\activate.bat\nYou should see (.venv) appear at the start of the line.\n\n\n3D) Install the notebook packages (first-time setup)\nStill in the activated environment, run:\npython -m pip install --upgrade pip\npython -m pip install numpy pandas matplotlib jupyter\n\n\n3E) Select the environment in VS Code (Interpreter)\n\nIn VS Code, press Ctrl + Shift + P\nType Python: Select Interpreter\nChoose the interpreter that looks like:\n\n\nC:\\cmsc-1217-env\\.venv\\Scripts\\python.exe\n\nIf you don’t see it:\n\nchoose Enter interpreter path…\npaste: C:\\cmsc-1217-env\\.venv\\Scripts\\python.exe\n\nThis is the environment we will use all semester.\n\n\n\n4) Open the notebook\n\nIn the Explorer panel, click the notebook file (.ipynb) your instructor provided.\n\n\n\n5) Select the notebook kernel (first time only)\nThe first time you run a notebook, VS Code may ask you to pick a kernel.\nChoose the kernel that matches the course environment path:\n\nC:\\cmsc-1217-env\\.venv\\Scripts\\python.exe\n\nThis can feel repetitive the first time. That’s normal. Once selected, it usually stays set for that folder.\n\n\n6) Select the kernel, then run a quick test\n\nIn the top-right of the notebook, click Select Kernel.\nChoose the kernel that points to the course environment:\nC:\\cmsc-1217-env\\.venv\\Scripts\\python.exe\n(It may also show up as “Python 3.x (.venv)”—the key is that it points to cmsc-1217-env\\.venv.)\nClick + Code.\nIn the code block that appears, paste:\n\nprint(\"Notebook is running\")\n\nRun it by clicking the Run (▶) icon on the code block, or press Shift + Enter.\nYou should see Notebook is running appear underneath.\n\n\n\n7) Quick confirmation (your instructor may ask for this)\nRun this in a cell:\nimport sys\nsys.executable\nIt should show something like:\nC:\\cmsc-1217-env\\.venv\\Scripts\\python.exe\n\n\nIf something goes wrong\n\nIf you see ModuleNotFoundError (missing package), you are almost always using the wrong interpreter/kernel.\n\nRe-do Step 3 and Step 5 and pick the one that points to cmsc-1217-env\\.venv."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html",
    "href": "shared/guides/setup/miniconda.html",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "",
    "text": "You will use the same core setup in both of these courses:\nThe difference between the courses is which environment/packages you install and which tools are emphasized. This page includes small callouts to help you follow the right parts at the right time."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#overview",
    "href": "shared/guides/setup/miniconda.html#overview",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "Overview",
    "text": "Overview\nIn these courses, you will work inside a conda environment. An environment is an isolated Python installation (Python + packages) stored in a folder on your computer. This helps everyone use consistent tools and reduces setup conflicts.\nYou will use the following tools:\n\nMiniconda Miniconda is a small installer that provides Conda, a system for managing Python installations and packages. Miniconda does not include many data-science packages by default; instead, it gives you a controlled way to install exactly what a course requires.\nConda (the environment manager) Conda is software that can create, activate, and manage environments. It can also install packages (libraries) in a way that keeps them consistent and reduces compatibility problems, especially for scientific packages.\nConda environment A conda environment is a self-contained folder that contains:\n\na specific version of Python, and\na specific set of installed packages. Each environment is separate from other environments on your computer. This means one course can use one set of packages (and versions) without affecting another course or your personal Python installation.\n\nJupyterLab (notebook workspace) JupyterLab is a browser-based programming environment used for data analysis and machine learning. It allows you to write code in cells, run those cells, and view output (tables, plots, printed results) directly below the code. JupyterLab is used in both courses because it supports step-by-step work and makes it easier to review results.\nIPython (interactive Python terminal — CMSC-1217 only) IPython is an enhanced interactive Python terminal. It provides features that support exploratory work, such as command history, tab completion, and built-in help. In CMSC-1217, IPython is used to practice interactive exploration and reinforce core Python concepts in a terminal-based workflow.\n\nHow these pieces fit together\nMiniconda installs Conda, and Conda is the tool you use to create a course environment. When you activate that environment, your terminal temporarily switches so that the python command (and tools like jupyter) run from the environment’s folder. You then start Jupyter (JupyterLab or Jupyter Notebook), and the notebook runs Python from the active environment, using the packages installed there. This sequence—install Miniconda → create environment → activate environment → start Jupyter → run notebooks—is the standard workflow you will use throughout the course.\n\nImportant: During Miniconda installation, do not add Miniconda to PATH. We will use the Miniconda/Anaconda Prompt when working for these courses."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#install-miniconda",
    "href": "shared/guides/setup/miniconda.html#install-miniconda",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "1) Install Miniconda",
    "text": "1) Install Miniconda\n\nDownload and install Miniconda (64-bit) for Windows. https://www.anaconda.com/download\nDuring installation, do not add Miniconda to PATH.\n\nWhy not add to PATH: Many of you already have a Python installation from python.org. Not adding Miniconda to PATH prevents Miniconda from changing which python runs in non-course terminals.\nMiniconda is a lightweight installer that provides:\n\nConda (a package and environment manager), and\na basic Python installation and its dependencies.\n\nMiniconda is intentionally minimal: it does not install a large collection of data-science packages by default. Instead, you install only the packages required for the course.\nRelationship to Anaconda\nMiniconda and Anaconda are closely related:\n\nAnaconda Distribution is a larger installer that comes with hundreds of packages pre-installed, plus optional tools like Anaconda Navigator.\nMiniconda is a smaller installer that includes only conda, Python, and a small core set of packages, and then you add what you need.\n\nFor these courses, Miniconda is a good fit because it helps us keep your course environment clean, consistent, and easier to troubleshoot.\nWhy Miniconda/Conda is common in data analysis and machine learning\nData analysis and machine learning often rely on libraries that include compiled components. Conda is widely used in these areas because it can install many scientific packages as prebuilt binaries, which reduces installation difficulties (especially on Windows).\nConda also supports creating separate environments so different projects can use different versions of Python/packages without interfering with each other."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#open-the-conda-terminal",
    "href": "shared/guides/setup/miniconda.html#open-the-conda-terminal",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "2) Open the conda terminal",
    "text": "2) Open the conda terminal\nOpen Anaconda Command Prompt from the Start menu.\nYou should see something like:\n(base) C:\\Users\\yourname&gt;\nWhy we use this terminal\nAnaconda/Miniconda Prompt is a terminal that is already configured to recognize conda commands such as conda createand conda activate. Using this prompt reduces setup errors because it starts with the correct conda settings.\nWhat (base) means\n(base) indicates that you are currently in conda’s default environment. This environment exists mainly so that conda can run and manage other environments. In this course, you will usually not do your work in (base). Instead, you will create and activate a course environment (for example, pydata-book or cmsc-2208) and work there.\nHow to interpret the prompt\nThe name in parentheses is your current environment:\n\n(base) means you are in the default conda environment\n(pydata-book) or (cmsc-2208) means you are in the course environment\n\nA quick habit that prevents many problems: before running course commands, look at the parentheses and confirm you are in the correct environment."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#configure-conda-package-channels",
    "href": "shared/guides/setup/miniconda.html#configure-conda-package-channels",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "3) Configure conda package channels",
    "text": "3) Configure conda package channels\nRun the following two commands, one at a time, pressing Enter after each.\nFirst, run:\nconda config --add channels conda-forge\nThen, run:\nconda config --set channel_priority strict\nConda downloads packages from sources called channels. A channel is a repository that hosts packaged software (similar in purpose to an “app store,” but for programming libraries). When you install a package with conda, conda searches the configured channels to find a compatible version of that package and its dependencies.\nWe use conda-forge because it is a widely used community-maintained channel that provides current, well-tested builds of many scientific and data-analysis libraries (for example, NumPy, pandas, matplotlib, and scikit-learn). Using a consistent channel helps ensure that most students receive the same package builds and reduces platform-specific installation problems.\nSetting strict channel priority means conda will prefer packages from the highest-priority channel (in this case, conda-forge) rather than mixing packages from multiple channels. This matters because mixing package sources can sometimes lead to version conflicts or dependency mismatches. Strict priority reduces those problems by keeping package selection consistent."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#create-the-course-environment",
    "href": "shared/guides/setup/miniconda.html#create-the-course-environment",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "4) Create the course environment",
    "text": "4) Create the course environment\nYou will create one conda environment for the course you are taking currently.\nWhat an environment is:\nIn programming, an environment is the set of software used to run your code, such as:\n\nthe language runtime (for us, Python),\ninstalled libraries/packages,\nand related tools (such as Jupyter).\n\nMany languages and toolchains support environments (for example, Python can use virtual environments, and other ecosystems have their own dependency managers). The goal is the same: keep project dependencies organized and consistent.\nWhat a conda environment is:\nIn this course we use a conda environment, which is a self-contained folder on your computer that includes:\n\na specific version of Python, and\na specific set of installed packages.\n\nWe use conda because it provides a consistent way to install scientific and data-analysis libraries (especially on Windows) and makes it straightforward to reproduce the same setup across different computers.\nDo not create both environments.\nIf you are in CMSC-1217 Introduction to Data Analytics\nRun this command (then press Enter):\nconda create -n pydata-book python=3.11\nIf prompted, type y.\nThis creates an environment named pydata-book. The name is just a label for this course’s Python setup.\nIf you are in CMSC-2208 Introduction to Machine Learning\nRun this command (then press Enter):\nconda create -n cmsc-2208 python=3.11\nIf prompted, type y.\nThis creates an environment named cmsc-2208. The name is just a label for this course’s Python setup."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#activate-the-environment-choose-your-course",
    "href": "shared/guides/setup/miniconda.html#activate-the-environment-choose-your-course",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "5) Activate the environment (choose your course)",
    "text": "5) Activate the environment (choose your course)\nBefore installing packages or starting JupyterLab, you must activate your course environment.\nWhat “activate” means: It tells the terminal to use the Python and packages inside your course environment. When the environment is active, commands like python and jupyter will run from the correct course setup.\nYou will activate one environment: the one for the course you are taking now.\n\nIf you are in CMSC-1217 Introduction to Data Analytics\nRun:\nconda activate pydata-book\n\n\nIf you are in CMSC-2208 Introduction to Machine Learning\nRun:\nconda activate cmsc-2208\nAfter you activate, your prompt will begin with the environment name, for example:\n\n(pydata-book) ...\n(cmsc-2208) ...\n\nRule: Before you do course work, confirm that the prompt shows your course environment name."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#install-packages-inside-the-active-environment",
    "href": "shared/guides/setup/miniconda.html#install-packages-inside-the-active-environment",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "6) Install packages (inside the active environment)",
    "text": "6) Install packages (inside the active environment)\n\nA) CMSC-1217 packages\nWith (pydata-book) active, run:\nconda install -c conda-forge numpy pandas=2.0.3 matplotlib jupyterlab notebook ipykernel\nThis installs:\n\nnumpy: arrays and numerical computing\npandas: data tables (DataFrames)\nmatplotlib: plotting\njupyterlab: notebook interface\nipykernel: the component that allows this environment to run notebooks as a Jupyter kernel\n\n\nCMSC-1217 only: You will also use IPython in this course. IPython will work once the environment is active.\n\n\n\nB) CMSC-2208 packages (required)\nWith (cmsc-2208) active, run:\nconda install -c conda-forge numpy pandas matplotlib jupyterlab notebook ipykernel scikit-learn scipy\nThis installs the data stack plus the machine learning libraries used in CMSC-2208."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#verify-your-installation-imports-version-confirmation",
    "href": "shared/guides/setup/miniconda.html#verify-your-installation-imports-version-confirmation",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "7) Verify your installation (imports + version confirmation)",
    "text": "7) Verify your installation (imports + version confirmation)\nRun this command in the active environment:\npython -c \"import sys; import numpy as np; import pandas as pd; import matplotlib; print('python', sys.version.split()[0]); print('numpy', np.__version__); print('pandas', pd.__version__); print('matplotlib', matplotlib.__version__)\"\nWhat this step is doing (and why it can take a moment):\nThis command does two things:\n\nImports the core libraries (numpy, pandas, matplotlib). Importing is the real verification step. It confirms the packages are installed correctly in this environment and that Python can load them without errors.\nPrints version numbers after the imports succeed. This helps confirm you are using the expected tool versions for the course.\n\nBecause these libraries are large and include compiled components, the first successful import in a new environment may take longer than you expect. That is normal.\n\nCMSC-2208 only\nFor CMSC-2208, also verify:\npython -c \"import sklearn, scipy; print('sklearn', sklearn.__version__); print('scipy', scipy.__version__)\"\nThis confirms that the machine learning libraries required for the course can be imported correctly in the CMSC-2208 environment."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#create-the-course-folder-structure-choose-your-course",
    "href": "shared/guides/setup/miniconda.html#create-the-course-folder-structure-choose-your-course",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "8) Create the course folder structure (choose your course)",
    "text": "8) Create the course folder structure (choose your course)\nYou will create a small folder structure on your C: drive so your files stay organized and easy to find.\nRun the commands for your course only. Run them one at a time, pressing Enter after each command.\n\nIf you are in CMSC-1217 Introduction to Data Analytics\nRun the following four commands:\nFirst:\nmkdir C:\\cmsc-1217\nThen:\nmkdir C:\\cmsc-1217\\course-work\nThen:\nmkdir C:\\cmsc-1217\\book\nFinally:\nmkdir C:\\cmsc-1217\\data\n\n\nIf you are in CMSC-2208 Introduction to Machine Learning\nRun the following four commands:\nFirst:\nmkdir C:\\cmsc-2208\nThen:\nmkdir C:\\cmsc-2208\\course-work\nThen:\nmkdir C:\\cmsc-2208\\book\nFinally:\nmkdir C:\\cmsc-2208\\data\n\n\nWhat these folders are for (both courses)\n\ncourse-work: your weekly work and submissions\nbook: companion notebooks (reference materials)\ndata: datasets used in course work\n\nNote: If you see a message like “A subdirectory or file already exists,” that usually means you already created the folder. That is fine—continue to the next command."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#install-git-if-needed",
    "href": "shared/guides/setup/miniconda.html#install-git-if-needed",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "9) Install Git (if needed)",
    "text": "9) Install Git (if needed)\nCheck:\ngit --version\nIf Git is not installed, install Git for Windows, then re-check git --version."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#download-the-book-companion-files-choose-your-course",
    "href": "shared/guides/setup/miniconda.html#download-the-book-companion-files-choose-your-course",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "10) Download the book companion files (choose your course)",
    "text": "10) Download the book companion files (choose your course)\nEach course uses a GitHub repository that contains companion files (notebooks, datasets, and examples). You will download the repository into your course book folder.\nRun the commands for your course only. Run them one at a time, pressing Enter after each command.\n\nIf you are in CMSC-1217 Introduction to Data Analytics\nFirst, move into your book folder:\ncd C:\\cmsc-1217\\book\nThen, clone the companion repository:\ngit clone -b 3rd-edition https://github.com/wesm/pydata-book.git\nThis creates the folder:\nC:\\cmsc-1217\\book\\pydata-book\\\n\n\nIf you are in CMSC-2208 Introduction to Machine Learning\nFirst, move into your book folder:\ncd C:\\cmsc-2208\\book\nThen, clone the companion repository:\ngit clone https://github.com/amueller/introduction_to_ml_with_python.git\nThis creates the folder:\nC:\\cmsc-2208\\book\\introduction_to_ml_with_python\\\nNote: If you see a message that the folder already exists, that usually means you already cloned the repository. That is fine—do not clone it again."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#start-jupyter-notebook-in-the-correct-folder-choose-yourcourse",
    "href": "shared/guides/setup/miniconda.html#start-jupyter-notebook-in-the-correct-folder-choose-yourcourse",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "11) Start Jupyter Notebook in the correct folder (choose yourcourse)",
    "text": "11) Start Jupyter Notebook in the correct folder (choose yourcourse)\nYou will start the Jupyter Notebook (Classic) server from your course-work folder. This ensures that when the browser opens, you immediately see the files you are expected to edit and submit.\nRun the commands for your course only. Run them one at a time, pressing Enter after each command.\n\nIf you are in CMSC-1217 Introduction to Data Analytics\nFirst, confirm you are in the correct course environment. Conda environments are activated per terminal window. That means:\n\nIf you are using the same Anaconda/Miniconda Prompt window as earlier steps, your environment may already be active.\nIf you opened a new terminal window (or restarted your computer), you must activate the environment again.\n\nRun:\nconda activate pydata-book\nCheck: your prompt should begin with (pydata-book).\nNext, move into your course work folder:\ncd C:\\cmsc-1217\\course-work\nThen start Jupyter Notebook (Classic):\njupyter notebook\n\n\nIf you are in CMSC-2208 Introduction to Machine Learning\nFirst, confirm you are in the correct course environment. Conda environments are activated per terminal window. That means:\n\nIf you are using the same Anaconda/Miniconda Prompt window as earlier steps, your environment may already be active.\nIf you opened a new terminal window (or restarted your computer), you must activate the environment again.\n\nRun:\nconda activate cmsc-2208\nCheck: your prompt should begin with (pydata-book).\nNext, move into your course work folder:\ncd C:\\cmsc-2208\\course-work\nThen start Jupyter Notebook (Classic):\njupyter notebook\nA browser tab will open showing the contents of your course-work folder.\nImportant: Leave the terminal window open while you use Jupyter Notebook. That terminal is running the notebook server. If you close it, Jupyter will stop.\n\n\nAccessing the book folder (when needed)\nThe course keeps course-work (your work) and book (reference materials) separate on purpose. When you need to view a book notebook:\nStart a second Jupyter Notebook server in the book folder.\n\nOpen a second Anaconda/Miniconda Prompt window\nActivate the same environment\ncd into the book folder\nRun jupyter notebook\n\nFor CMSC-1217 (run each command seperately):\nconda activate pydata-book\ncd C:\\cmsc-1217\\book\njupyter notebook\nFor CMSC-2208 (run each command seperately):\nconda activate cmsc-2208\ncd C:\\cmsc-2208\\book\njupyter notebook\nThis opens a second browser tab rooted in the book folder."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#create-your-first-notebook-and-confirm-the-environment",
    "href": "shared/guides/setup/miniconda.html#create-your-first-notebook-and-confirm-the-environment",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "12) Create your first notebook and confirm the environment",
    "text": "12) Create your first notebook and confirm the environment\n\nIn your browser, go to the file list page (the page that shows folders/files).\n\nIf you are currently inside a notebook, click File → Open… to return to the file list.\n\nClick New (top-right), then select Python 3 (ipykernel).\nIn the first cell, run:\n\nimport sys\nsys.executable\n\nConfirm the path includes your course environment:\n\n\nCMSC-1217: \\\\envs\\\\pydata-book\\\\\nCMSC-2208: \\\\envs\\\\cmsc-2208\\\\\n\nWhy this matters: The kernel name shown in menus can vary, but sys.executable reliably confirms the notebook is using the correct environment."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#stop-jupyterlab-when-finished",
    "href": "shared/guides/setup/miniconda.html#stop-jupyterlab-when-finished",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "13) Stop JupyterLab when finished",
    "text": "13) Stop JupyterLab when finished\nGo back to the terminal that started JupyterLab and press:\n\nCtrl + C, then type y if prompted."
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#optional-cmsc-1217-ipython-in-the-terminal",
    "href": "shared/guides/setup/miniconda.html#optional-cmsc-1217-ipython-in-the-terminal",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "Optional (CMSC-1217): IPython in the terminal",
    "text": "Optional (CMSC-1217): IPython in the terminal\n\nCMSC-1217 only: You will use IPython for interactive exploration.\n\nIn Anaconda/Miniconda Prompt:\nconda activate pydata-book\nIPython\nYou should see an In [1]: prompt.\nTo exit:\nexit()"
  },
  {
    "objectID": "shared/guides/setup/miniconda.html#common-issues-and-solutions",
    "href": "shared/guides/setup/miniconda.html#common-issues-and-solutions",
    "title": "Shared Setup (Windows) — Miniconda, Course Environments, IPython, and JupyterLab",
    "section": "Common issues and solutions",
    "text": "Common issues and solutions\n\nIssue: Imports fail inside a notebook\nMost common cause: the wrong environment/kernel is active.\nSolution\n\nIn the notebook, run sys.executable to confirm the environment path.\nIf it is incorrect, switch the notebook kernel to the correct one:\n\nKernel → Change Kernel (select the environment for your course)\n\n\n\n\nIssue: JupyterLab opens in the wrong folder\nSolution: cd into the correct course-work folder before starting JupyterLab.\n\n\nIssue: You forgot to activate the environment\nSolution: close JupyterLab (Ctrl+C), then re-run the launch commands in Section 11."
  },
  {
    "objectID": "shared/policies/general-policies.html",
    "href": "shared/policies/general-policies.html",
    "title": "General Course Policies",
    "section": "",
    "text": "Academic integrity\n\nStudents must maintain academic integrity (no cheating, plagiarism, unauthorized materials, falsification, etc.).\nViolations follow SCTCC Academic Integrity Policy/Procedure and may be recorded; disciplinary action may apply.\nAcademic integrity violations result in a grade reduction.\n\n\n\nProfessional conduct and behavior\n\nOnline discussions must be civil, respectful, and relevant.\nDisruptive behavior on any course communication platform is not tolerated; may result in grade penalties and/or removal per the Code of Student Conduct.\nRespect for differing viewpoints is required; maintain professional language and conduct.\nIf disruptive behavior causes a student to miss an assignment, they receive no credit for that assignment.\nIf sanctioned for disruptive behavior, students waive the right to a warning on a second occurrence.\nSubstance policy for online sessions: inebriation/being under the influence, displaying alcohol, or drug paraphernalia results in removal from the session and/or course; no smoking during online school activites.\n\n\n\nStudent privacy / third-party communication\n\nCourse progress is discussed only with the student, not parents/guardians/third parties, unless an Information Release is on file.\nIf a third party contacts the instructor, the instructor will defer communication to the student.\nStudents may not invite third parties to attend any online activity (office hours, group meetings).\nRequests to release progress information to a third party should go through the Dean’s office.\n\n\n\nAttendance / participation\n\nAttendance is expected and monitored; students are responsible for tracking absences.\nAttendance is determined by D2L logins and weekly assignment submissions.\nNot logging in and/or not submitting work for a week counts as an absence (including weeks without due assignments unless it’s a scheduled holiday/break).\nStudents must log in and complete an activity by 11:30 PM on the first Wednesday of week 1 or they may be dropped.\nMissing two consecutive weeks → dropped.\nMissing two total weeks → one-letter-grade reduction (10% of total points).\nMissing three total weeks → an additional one-letter-grade reduction.\nAdditional absences beyond three → additional letter-grade reduction per occurrence.\nAttendance is handled per class (one class doesn’t cover another).\n\n\n\nTechnology and platform expectations\n\nStudents are responsible for having required computer/technology for the course.\nStudents are responsible for learning and using D2L (primary channel for schedules, grades, and announcements).\n\n\n\nEmail communication\n\nEmail is the primary method to contact the instructor; students must use their college email account.\nEmails must include a subject line with course name and section/class time.\nStudents are expected to check email daily and read instructor messages/attachments.\nOn nights homework is due, only administrative email items will be answered; technical homework questions will not be addressed.\nResponse time: by end of next business day; Friday emails answered Monday.",
    "crumbs": [
      "Home",
      "Course information",
      "General Policies"
    ]
  },
  {
    "objectID": "shared/policies/office-hours.html",
    "href": "shared/policies/office-hours.html",
    "title": "Office Hours",
    "section": "",
    "text": "Mondays - 3:00–4:00 PM and 6:00–7:00 PM\nPersistent Zoom link: Join Zoom meeting",
    "crumbs": [
      "Home",
      "Course information",
      "Office Hours"
    ]
  },
  {
    "objectID": "shared/policies/office-hours.html#no-office-hours",
    "href": "shared/policies/office-hours.html#no-office-hours",
    "title": "Office Hours",
    "section": "No office hours",
    "text": "No office hours\nOffice hours are not held on:\nJan 19 — Martin Luther King — No Classes — College Closed\nFeb 16 — President’s Day — No Classes — College Closed\nMar 9–13 — Spring Break — No Classes\nMay 11–15 — Final Exams",
    "crumbs": [
      "Home",
      "Course information",
      "Office Hours"
    ]
  },
  {
    "objectID": "weekly-overview/week-02/index.html",
    "href": "weekly-overview/week-02/index.html",
    "title": "Week 2 Guide",
    "section": "",
    "text": "The focus of Week 2 is to complete Virtual Pet v1 and submit a working, well-explained program. You will finish the Pet class requirements, complete the full menu behavior, and add data persistence using pickling so the program can save and reload the pet’s state.\nWeek 2 includes a graded submission. Your goal is both correctness (meeting the requirements) and clear explanation of your design choices.",
    "crumbs": [
      "Home",
      "Weekly Overview",
      "Week 2"
    ]
  },
  {
    "objectID": "weekly-overview/week-02/index.html#week-2-focus",
    "href": "weekly-overview/week-02/index.html#week-2-focus",
    "title": "Week 2 Guide",
    "section": "",
    "text": "The focus of Week 2 is to complete Virtual Pet v1 and submit a working, well-explained program. You will finish the Pet class requirements, complete the full menu behavior, and add data persistence using pickling so the program can save and reload the pet’s state.\nWeek 2 includes a graded submission. Your goal is both correctness (meeting the requirements) and clear explanation of your design choices.",
    "crumbs": [
      "Home",
      "Weekly Overview",
      "Week 2"
    ]
  },
  {
    "objectID": "weekly-overview/week-02/index.html#week-2-project-work-virtual-pet-v1-final",
    "href": "weekly-overview/week-02/index.html#week-2-project-work-virtual-pet-v1-final",
    "title": "Week 2 Guide",
    "section": "Week 2 project work: Virtual Pet v1 (final)",
    "text": "Week 2 project work: Virtual Pet v1 (final)\nBy the end of Week 2, your program should support the full assignment workflow:\n\ncreate a new pet (name, color, type) when no saved file exists\nrepeatedly display a menu until the user chooses to save and exit\nhandle invalid menu input without crashing (this must be demonstrated)\nimplement the required Pet class methods and behaviors\nsave the pet state and load it on the next run (pickling)",
    "crumbs": [
      "Home",
      "Weekly Overview",
      "Week 2"
    ]
  },
  {
    "objectID": "weekly-overview/week-02/index.html#reading-learning-python-6th-edition",
    "href": "weekly-overview/week-02/index.html#reading-learning-python-6th-edition",
    "title": "Week 2 Guide",
    "section": "Reading (Learning Python, 6th Edition)",
    "text": "Reading (Learning Python, 6th Edition)\nContinue working through Chapters 1–7. This reading supports the language features used in the project (control flow, loops, functions, and basic class structure). Finish the reading by the end of Week 2.",
    "crumbs": [
      "Home",
      "Weekly Overview",
      "Week 2"
    ]
  },
  {
    "objectID": "weekly-overview/week-02/index.html#week-2-tasks",
    "href": "weekly-overview/week-02/index.html#week-2-tasks",
    "title": "Week 2 Guide",
    "section": "Week 2 tasks",
    "text": "Week 2 tasks\nComplete the following tasks during Week 2:\n\nFinish the Pet class\n\nImplement the required attributes and method behaviors.\nUse conditionals in feed, play, and rest to reflect the pet’s state.\nEnsure values remain within the expected bounds (0–10).\n\nComplete the menu-driven program\n\nMake each menu option call the correct method and report feedback to the user.\nImplement input validation so invalid choices display an error and the program continues.\n\nAdd data persistence (pickling)\n\nImplement save_pet and load_pet in main().\nSave the pet state when the user selects Save and Exit.\nLoad an existing saved pet automatically when the program starts.\nHandle the “no saved file exists yet” case cleanly.\n\nPrepare submission deliverables\n\nConfirm the program runs from a clean start.\nRecord the required video explanation and include the required demonstrations.\nSubmit the required files to the Week 2 D2L dropbox.",
    "crumbs": [
      "Home",
      "Weekly Overview",
      "Week 2"
    ]
  },
  {
    "objectID": "weekly-overview/week-02/index.html#knowledge-goals-for-week-2",
    "href": "weekly-overview/week-02/index.html#knowledge-goals-for-week-2",
    "title": "Week 2 Guide",
    "section": "Knowledge goals for Week 2",
    "text": "Knowledge goals for Week 2\nBy the end of Week 2, you should be able to:\n\nimplement a class that models state and behavior using methods and conditionals\nbuild a reliable menu loop with input validation for a CLI program\nsave and load program state using pickling\nexplain your program structure and design choices clearly in a short walkthrough",
    "crumbs": [
      "Home",
      "Weekly Overview",
      "Week 2"
    ]
  }
]