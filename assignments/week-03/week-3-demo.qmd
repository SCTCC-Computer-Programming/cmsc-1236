---
title: CMSC 1236 — Week 3 Demo
jupyter: python3
---

## Learning Python 6e (Ch. 8–9): Collections (Sequences, Mappings, Sets) + `pathlib`

CMSC 1203 introduced lists, dictionaries, and sets with an emphasis on correct use: create a data structure, loop over it, and produce correct output. Chapters 8–9 build on that foundation by explaining how Python’s built-in types behave at runtime.

In this notebook, the term collection type refers to a built-in type that groups multiple values into a single object (for example: list, dict, set, and tuple). The goal is to understand how these types store and share references, and how operations on them affect program behavior as code and data structures become larger.

After completing these examples, you should be able to:

* explain the difference between identity and equality (`is` vs `==`)
* distinguish rebinding from in-place mutation and predict when aliasing causes a change to appear in more than one place
* use list operations shown in the reading (including slice assignment and nested list construction) and predict when they modify an existing list
* describe key dictionary behaviors emphasized in the reading: insertion order, safe key access, and controlled updates
* use sets for uniqueness and understand why set elements must be hashable
* explain why tuples are used for fixed groupings and why item assignment is not allowed
* copy nested structures intentionally by choosing between a shallow copy and a deep copy
* read and write a text file using `pathlib.Path` (`read_text()` and `write_text()`)


## Part 1: Names, objects, and references

In Python, a variable is a *name* that refers to an object. An object is a value stored in memory (for example, a list, a dictionary, an integer, or a string). When a name refers to an object, the name is said to be **bound** to that object.

This model is a basic part of programming in Python. It explains how changes to lists and dictionaries propagate through a program, and it helps you predict what happens when the same object is reused in more than one place. It also applies when a value is passed into a function, meaning the object is provided to a function as an argument so the function can use it. If the argument is a mutable object (an object whose contents can be changed after it is created) and the function mutates it, the change is visible after the function call because the same object is being used.

Python’s built-in collection types (lists, dictionaries, sets, and tuples) store references to objects rather than copying them. As a result, the same object can be reached through more than one name.

Two operations are used throughout Python programs, and they are easy to confuse because both can occur after an assignment statement. The difference is what changes:

* rebinding changes which object a name refers to; the original object is unchanged
* mutation changes the contents of an existing object; any name that refers to that object will observe the change

Because Python programs frequently reuse objects through multiple names (intentionally or unintentionally), it is important to distinguish “same object” from “same value" so you can predict when a change will affect more than one variable. Two comparison operators are used for that purpose:

* `is` tests identity: whether two names refer to the same object in memory
* `==` tests equality: whether two objects have the same value

The following two examples establish the difference between identity and equality for collection objects.

### Example 1: Two names referring to the same object
This first example shows what it means for two names to refer to the same object. The output will confirm that `a is b` is true (same object) and `a == b` is also true (same contents).

```{python}
a = [1, 2, 3]
b = a
print("a =", a)
print("b =", b)
print("a is b =", a is b)
print("a == b =", a == b)
```
Explanation:

1. `a = [1, 2, 3]` creates a list object containing the integers `1`, `2`, and `3`, and assigns the name `a` to refer to that list.
2. `b = a` assigns the name `b` to refer to the same list object as `a`. No new list is created.
3. `print("a =", a)` prints the label `a =` followed by the current value of `a` (the list object that `a` refers to).
4. `print("b =", b)` prints the label `b =` followed by the current value of `b` (the same list object, since `b` refers to the same object as `a`).
5. `print("a is b =", a is b)` prints the label `a is b =` followed by the result of the identity test `a is b`. This is `True` here because `a` and `b` refer to the same object in memory.
6. `print("a == b =", a == b)` prints the label `a == b =` followed by the result of the equality test `a == b`. This is `True` here because the two values have the same contents (and in this case they are the same list object).

### Example 2: Different objects with the same value

This example shows that two different list objects can still be equal in value. The key observation is that `x is y` is false because two separate list objects are created, while `x == y` is true because the contents of the two lists match.

```{python}
x = [1, 2]
y = [1, 2]

print("x =", x)
print("y =", y)
print("x is y =", x is y)
print("x == y =", x == y)
```

Explanation:

1. `x = [1, 2]` creates a list object containing the integers `1` and `2`, and assigns the name `x` to refer to that list.
2. `y = [1, 2]` creates a second list object containing the integers `1` and `2`, and assigns the name `y` to refer to that second list. Even though the contents match, this is a different object in memory from the one referenced by `x`.
3. `print("x =", x)` prints the label `x =` followed by the current value of `x` (the list object that `x` refers to).
4. `print("y =", y)` prints the label `y =` followed by the current value of `y` (the list object that `y` refers to).
5. `print("x is y =", x is y)` prints the label `x is y =` followed by the result of the identity test `x is y`. This is `False` because `x` and `y` refer to different list objects in memory.
6. `print("x == y =", x == y)` prints the label `x == y =` followed by the result of the equality test `x == y`. This is `True` because the two lists contain the same values in the same order.

## Part 2) Rebinding vs in-place mutation (lists)

Lists are mutable sequence objects, which means their contents can be changed after they are created. When lists are used in a program, two different kinds of changes are common:

* a name can be reassigned to refer to a different list (rebinding)
* an existing list can be changed directly (in-place mutation)

This distinction matters because it affects whether a change is visible in other parts of a program. If two names refer to the same list object, then an in-place change is observed through both names. If a name is rebound to a new list object, other names that still refer to the original list are unaffected.

The following examples use two names (`nums` and `alias`) that initially refer to the same list so that the difference between rebinding and mutation is visible in the output.

### Example 1: Rebinding creates a new list

In this example, `nums = nums + [40]` produces a new list object and assigns `nums` to refer to that new list. The name `alias` continues to refer to the original list.

Beginner-friendly version:

```{python}
nums = [10, 20, 30]
alias = nums

nums = nums + [40]

print("nums =", nums)
print("alias =", alias)
print("nums is alias =", nums is alias)
```

Explanation:

1. `nums = [10, 20, 30]` creates a list object containing `10`, `20`, and `30`, and assigns the name `nums` to refer to it.
2. `alias = nums` assigns the name `alias` to refer to the same list object as `nums`. No new list is created.
3. `nums = nums + [40]` uses + to create a new list that contains the items from the original nums list followed by 40. After the new list is created, nums is rebound so it refers to the new list object. The original list object is not changed in place, so alias still refers to the original list.
4. `print("nums =", nums)` prints the new list that `nums` now refers to.
5. `print("alias =", alias)` prints the original list that `alias` still refers to.
6. `print("nums is alias =", nums is alias)` prints whether `nums` and `alias` refer to the same list object. This is `False` because `nums` was rebound to a different list.



### Example 2: In-place mutation changes the existing list

In this example, `nums += [40]` changes the existing list object in place. Because `alias` refers to the same list object, `alias` reflects the change as well.

Beginner-friendly version:

```{python}
nums = [10, 20, 30]
alias = nums

nums += [40]

print("nums =", nums)
print("alias =", alias)
print("nums is alias =", nums is alias)
```

Explanation:

1. `nums = [10, 20, 30]` creates a list object containing `10`, `20`, and `30`, and assigns the name `nums` to refer to it.
2. `alias = nums` assigns the name `alias` to refer to the same list object as `nums`. No new list is created.
3. `nums += [40]` modifies the existing list object in place by adding `40` to the end. The name `nums` still refers to the same list object as before.
4. `print("nums =", nums)` prints the modified list.
5. `print("alias =", alias)` prints the same modified list, because `alias` refers to the same object.
6. `print("nums is alias =", nums is alias)` prints whether `nums` and `alias` refer to the same list object. This is `True` because the list was mutated in place rather than replaced.


## 3) Lists (sequence type): slice assignment and nested list construction

This section focuses on two list operations that are easy to use correctly in small examples, but can cause confusion in larger programs if the effect on the existing list object is not understood.
First, lists support slice assignment, which replaces part of a list by assigning to a slice. A slice is a range of positions written as start:stop (the stop position is not included). This matters because slice assignment changes the existing list in place rather than creating a new list, so the change is visible anywhere that same list is referenced.

Second, lists support repetition with *. When the repeated item is itself a mutable object (such as a list), repetition can produce a nested structure in which multiple positions refer to the same inner object. This matters because changing one inner list then appears to change multiple “rows” at once.

The examples in this section demonstrate slice assignment as an in-place change, and they contrast two ways to build a list of lists: one that repeats references and one that creates independent inner lists.

### Example 1: Slice assignment modifies a list in place

Slice assignment replaces part of a list without creating a new list object. The key observation is that the list referenced by `data` changes, but `data` continues to refer to the same list object.

Beginner-friendly version:

```{python}
data = [0, 1, 2, 3, 4, 5]

print("before:", data)

data[2:5] = ["a", "b"]

print("after: ", data)
```

Explanation:

1. `data = [0, 1, 2, 3, 4, 5]` creates a list object containing six integers and assigns the name `data` to refer to it.
2. `print("before:", data)` prints the list before any changes are made.
3. `data[2:5] = ["a", "b"]` replaces the slice of `data` from index `2` up to (but not including) index `5` with the two elements `"a"` and `"b"`. This operation changes the existing list object in place.
4. `print("after: ", data)` prints the modified list so the effect of the slice assignment is visible.


### Example 2: Nested lists and repeated references (`*` repetition)

List repetition with `*` repeats references when the repeated element is a mutable object (such as a list). The key observation is that changing one inner list changes every “row” when all rows refer to the same inner list object.

Beginner-friendly version (repeated references):

```{python}
row = [0, 0]
grid_bad = [row] * 3

print("before:", grid_bad)

grid_bad[0][0] = 99

print("after: ", grid_bad)
```

Explanation:

1. `row = [0, 0]` creates a list object containing two zeros and assigns the name `row` to refer to it.
2. `grid_bad = [row] * 3` creates a new outer list with three elements, but each element is a reference to the same inner list object referenced by `row`. No independent inner lists are created.
3. `print("before:", grid_bad)` prints the nested list structure before mutation.
4. `grid_bad[0][0] = 99` changes the first element of the first inner list to `99`. Because all three “rows” refer to the same inner list object, the change appears in every row.
5. `print("after: ", grid_bad)` prints the nested list structure after mutation to show the repeated-reference effect.


### Example 3: Nested lists created as independent inner lists (recommended construction)

A common pattern for building nested lists is to construct each inner list independently so that mutating one row does not affect the others.

Beginner-friendly version (independent inner lists):

```{python}
grid_ok = [[0, 0] for _ in range(3)]

print("before:", grid_ok)

grid_ok[0][0] = 99

print("after: ", grid_ok)
```

Explanation:

1. `grid_ok = [[0, 0] for _ in range(3)]` builds a new outer list by running the expression `[0, 0]` three times, producing three separate inner list objects. The name `grid_ok` refers to the resulting nested list.
2. `print("before:", grid_ok)` prints the nested list structure before mutation.
3. `grid_ok[0][0] = 99` changes the first element of the first inner list to `99`. Because each row is a different inner list object, the change affects only the first row.
4. `print("after: ", grid_ok)` prints the nested list structure after mutation to show that only one row changed.


## 4) Dictionaries (mapping type): insertion order, safe access, and controlled updates

There are four dictionary behaviors in this unit that are important for writing predictable programs with mappings.

A dictionary is the built-in mapping type: it stores values by key rather than by position. Because dictionaries are used to represent configuration, lookup tables, and structured records, it is important to understand how key order behaves, how to access keys safely, and how to update dictionaries without accidentally changing an object that other parts of a program still rely on.

The examples that follow demonstrate:

* insertion order during iteration (order of insertion, not sorting),
* safe access using membership tests and `get` when keys may be missing,
* controlled updates using `copy` and `update` to preserve an original mapping,
* key-view comparisons using set operations to reason about which keys match or differ.


### Example 1: Insertion order (iteration is not sorting)

This example shows that dictionaries preserve the order in which keys were inserted. The key observation is that the dictionary’s key order matches insertion order, not alphabetical order.

Beginner-friendly version:

```{python}
d = {"b": 2, "a": 1, "c": 3}

print("dictionary =", d)
print("keys in iteration order =", list(d.keys()))
```

Explanation:

1. `d = {"b": 2, "a": 1, "c": 3}` creates a dictionary with three key-value pairs and assigns the name `d` to refer to it.
2. `print("dictionary =", d)` prints the dictionary so the insertion order is visible in the displayed representation.
3. `print("keys in iteration order =", list(d.keys()))` converts the dictionary’s keys view to a list and prints it. The result reflects insertion order.

### Example 2: Safe access with membership tests and `get`

This example shows two standard ways to handle keys that may or may not exist. The key observation is that membership tests report whether a key is present, and `get` returns a default value instead of raising an error when a key is missing.

Beginner-friendly version:

```{python}
config = {"mode": "test"}

print("config =", config)

print("'mode' in config =", "mode" in config)
print("'timeout' in config =", "timeout" in config)

print("config.get('mode') =", config.get("mode"))
print("config.get('timeout', 30) =", config.get("timeout", 30))
```

Explanation:

1. `config = {"mode": "test"}` creates a dictionary with one key-value pair and assigns `config` to refer to it.
2. `print("config =", config)` prints the dictionary.
3. `print("'mode' in config =", "mode" in config)` tests whether the key `"mode"` is present in the dictionary.
4. `print("'timeout' in config =", "timeout" in config)` tests whether the key `"timeout"` is present in the dictionary.
5. `print("config.get('mode') =", config.get("mode"))` retrieves the value for `"mode"`. Because the key exists, the value is returned.
6. `print("config.get('timeout', 30) =", config.get("timeout", 30))` attempts to retrieve the value for `"timeout"`. Because the key does not exist, the default value `30` is returned instead.


### Example 3: Controlled updates using `copy` and `update`

This example shows how to combine a base dictionary with an override dictionary without modifying the original. The key observation is that `copy` creates a new dictionary object, and `update` mutates that new dictionary by applying key-value pairs from another dictionary.

Beginner-friendly version:

```{python}
base = {"host": "localhost", "port": 8000}
override = {"port": 9000}

merged = base.copy()
merged.update(override)

print("base =", base)
print("override =", override)
print("merged =", merged)
```

Explanation:

1. `base = {"host": "localhost", "port": 8000}` creates a dictionary containing default settings.
2. `override = {"port": 9000}` creates a second dictionary containing settings that should replace or extend defaults.
3. `merged = base.copy()` creates a new dictionary object with the same key-value pairs as `base` and assigns `merged` to refer to it.
4. `merged.update(override)` modifies `merged` in place by applying key-value pairs from `override`. In this case, the `"port"` key is overwritten with `9000`.
5. The three `print` statements display `base`, `override`, and `merged` so that it is clear the original `base` dictionary was not changed.


### Example 4: Dictionary key views for comparisons

This example shows that `keys()` returns a view of keys that can be used in set operations. The key observation is that intersection identifies keys present in both dictionaries, and difference identifies keys present in one dictionary but not the other.

Beginner-friendly version:

```{python}
a = {"x": 1, "y": 2, "z": 3}
b = {"y": 20, "z": 30, "w": 40}

common = a.keys() & b.keys()
only_in_a = a.keys() - b.keys()

print("a keys =", list(a.keys()))
print("b keys =", list(b.keys()))
print("keys in both =", common)
print("keys only in a =", only_in_a)
```

Explanation:

1. `a = {"x": 1, "y": 2, "z": 3}` creates a dictionary with three keys and assigns `a` to refer to it.
2. `b = {"y": 20, "z": 30, "w": 40}` creates a second dictionary with an overlapping set of keys and assigns `b` to refer to it.
3. `common = a.keys() & b.keys()` computes the intersection of the two key views, producing the set of keys that appear in both dictionaries.
4. `only_in_a = a.keys() - b.keys()` computes the difference, producing the set of keys that appear in `a` but not in `b`.
5. The `print` statements display the keys and the computed comparisons.


## 5) Set types: uniqueness and hashability

A set is a built-in collection type used to represent a group of unique values. Unlike lists and tuples, sets do not keep items in a positional order, and duplicate values are automatically removed.

Sets are useful when the question is “is this value present?” or when a collection needs to be reduced to distinct values. To support fast membership testing, set elements must be hashable, which requires that an element’s value not change in a way that would affect its hash. For that reason, mutable objects such as lists cannot be set elements.

The examples that follow demonstrate two points: constructing a set removes duplicates from an input sequence, and attempting to place an unhashable value (such as a list) into a set results in an error.


### Example 1: De-duplication by constructing a set

This example shows that building a set from a list removes duplicate values. The key observation is that repeated items from the list appear only once in the set.

Beginner-friendly version:

```{python}
items = ["apple", "apple", "pear", "banana", "banana"]

unique_items = set(items)

print("original list =", items)
print("set (unique values) =", unique_items)
```

Explanation:

1. `items = ["apple", "apple", "pear", "banana", "banana"]` creates a list that contains repeated strings and assigns the name `items` to refer to it.
2. `unique_items = set(items)` constructs a set from the list. Because sets store only distinct values, duplicates are removed.
3. `print("original list =", items)` prints the original list so the duplicates are visible.
4. `print("set (unique values) =", unique_items)` prints the set so the unique values are visible.


### Example 2: Hashability requirement (what can be an element of a set)

This example shows that lists cannot be elements of a set. The key observation is that Python raises a `TypeError` because lists are mutable and therefore not hashable.

Beginner-friendly version:

```{python}
try:
    bad = {[1, 2], [3, 4]}
except TypeError as e:
    print("error:", e)
```

Explanation:

1. The `try` block attempts to create a set containing two list objects: `[1, 2]` and `[3, 4]`.
2. Python raises a `TypeError` because list objects are mutable and cannot be used as set elements.
3. The `except TypeError as e` block catches the error and prints the message so the reason for the failure is visible.

## 6) Tuples (sequence type, immutable): record-style grouping

A tuple is a built-in sequence type, which means it holds an ordered collection of items that can be accessed by position (index). Tuples are similar to lists in how they are written and indexed, but they differ in one important way.

A list is mutable, meaning its contents can be changed after it is created. A tuple is immutable, meaning that after a tuple is created, the individual items inside it cannot be replaced using assignment. This makes tuples useful for grouping a fixed set of related values into a single object, where each position has a stable meaning (for example, a first name, last name, and year).

The examples that follow demonstrate two points: tuple items can be accessed by index like other sequences, and attempting to assign to a tuple element results in an error because tuples do not support item assignment.


### Example 1: Accessing tuple items by index

This example shows that tuples support indexing. The key observation is that the first and last items can be accessed using `0` and `-1`, just as with lists.

Beginner-friendly version:

```{python}
record = ("Ada", "Lovelace", 1815)

print("record =", record)
print("first item =", record[0])
print("last item =", record[-1])
```

Explanation:

1. `record = ("Ada", "Lovelace", 1815)` creates a tuple containing three items and assigns the name `record` to refer to it.
2. `print("record =", record)` prints the tuple so its contents are visible.
3. `print("first item =", record[0])` prints the first item in the tuple (index `0`).
4. `print("last item =", record[-1])` prints the last item in the tuple (index `-1` counts from the end).


### Example 2: Tuples do not allow item assignment (immutability)

This example shows that tuple items cannot be reassigned. The key observation is that Python raises a `TypeError` when an assignment to a tuple element is attempted.

Beginner-friendly version:

```{python}
record = ("Ada", "Lovelace", 1815)

try:
    record[0] = "ADA"
except TypeError as e:
    print("error:", e)
```

Explanation:

1. `record = ("Ada", "Lovelace", 1815)` creates a tuple containing three items and assigns `record` to refer to it.
2. The `try` block attempts to assign a new value to `record[0]`.
3. Python raises a `TypeError` because tuples are immutable and do not support item assignment.
4. The `except TypeError as e` block catches the error and prints the message.


## 7) Copying nested collection objects (shallow vs deep)

When a collection contains other collection objects, the structure is nested. A nested structure is one where an outer object (such as a list) contains inner objects (such as other lists). When the inner objects are mutable, changes to an inner object can affect more than one variable if those variables share references to the same inner object.

Copying matters because programs often need a “starting version” of data and a “working version” of data at the same time. For example, a program might keep an original configuration, menu, or table of values unchanged while also building a modified version for output or for the next step in a computation. If the copy shares inner objects with the original, then changing the working version can unexpectedly change the original as well.

Two terms are used in this section:

* shallow copy: creates a new outer collection, but the inner objects are shared
* deep copy: creates a new outer collection and also creates copies of nested objects

The examples that follow show the practical difference by mutating an inner list and observing whether the original structure changes.


### Example 1: Shallow copy shares inner lists

This example shows that slicing a nested list (`nested[:]`) creates a new outer list but does not copy the inner lists. The key observation is that changing an inner list through the shallow copy also changes the original.

Beginner-friendly version:

```{python}
nested = [[1, 2], [3, 4]]
shallow = nested[:]

print("nested before =", nested)
print("shallow before =", shallow)

shallow[0].append(999)

print("nested after  =", nested)
print("shallow after =", shallow)
print("nested is shallow =", nested is shallow)
print("nested[0] is shallow[0] =", nested[0] is shallow[0])
```

Explanation:

1. `nested = [[1, 2], [3, 4]]` creates an outer list that contains two inner lists, and assigns `nested` to refer to it.
2. `shallow = nested[:]` creates a new outer list containing the same two inner list objects, and assigns `shallow` to refer to it. The inner lists are not copied.
3. The first two `print` statements display `nested` and `shallow` before any changes.
4. `shallow[0].append(999)` modifies the first inner list in place by appending `999`. Because `nested[0]` and `shallow[0]` refer to the same inner list object, the change appears in both `nested` and `shallow`.
5. The next two `print` statements display `nested` and `shallow` after the mutation.
6. `print("nested is shallow =", nested is shallow)` shows that the outer lists are different objects.
7. `print("nested[0] is shallow[0] =", nested[0] is shallow[0])` shows that the first inner list object is shared.



### Example 2: Deep copy creates independent nested objects

This example shows that a deep copy duplicates the nested structure. The key observation is that changing an inner list in the deep copy does not change the original.

Beginner-friendly version:

```{python}
import copy

nested = [[1, 2], [3, 4]]
deep = copy.deepcopy(nested)

print("nested before =", nested)
print("deep before   =", deep)

deep[0].append(999)

print("nested after  =", nested)
print("deep after    =", deep)
print("nested is deep =", nested is deep)
print("nested[0] is deep[0] =", nested[0] is deep[0])
```

Explanation:

1. `import copy` loads the `copy` module so that `deepcopy` can be used.
2. `nested = [[1, 2], [3, 4]]` creates an outer list containing two inner lists and assigns `nested` to refer to it.
3. `deep = copy.deepcopy(nested)` creates a new outer list and also creates new inner list objects with the same contents, then assigns `deep` to refer to the copied structure.
4. The first two `print` statements display `nested` and `deep` before any changes.
5. `deep[0].append(999)` modifies the first inner list in the deep copy by appending `999`.
6. The next two `print` statements display `nested` and `deep` after the mutation. `nested` is unchanged because the inner lists are not shared.
7. `print("nested is deep =", nested is deep)` shows that the outer lists are different objects.
8. `print("nested[0] is deep[0] =", nested[0] is deep[0])` shows that the first inner list objects are different, confirming that the nested lists were copied.


## 8) File access with `pathlib.Path` (modern interface)

Basic file handling using `open()` and a `with` block was introduced in CMSC 1203, and the textbook’s Chapter 9 presents that same approach as the standard, universal way to work with files in Python. This section does not re-teach that baseline.

Instead, the focus here is a modern alternative interface that is widely used in current Python code: the `pathlib` module. This module is not covered in CMSC 1203 and it is not a topic in Learning Python Chapters 8–9, but it is a practical tool that builds directly on the same underlying file concepts.

A `pathlib.Path` object represents a file path as an object rather than as a plain string. It can simplify common tasks such as reading and writing text and helps keep file-related code consistent and readable as programs grow.

The examples that follow demonstrate how to:

* create a `Path` object for a file,
* read an entire text file with `read_text()`,
* write text to a file with `write_text()`,
* and confirm the results by reading the file again.


### Example 1: File access with `pathlib.Path`

In a notebook, files are created in the notebook’s working directory. The working directory is the folder Python treats as the “current location” when you use a relative file name like `demo_text.txt`. If the file name does not include a folder path, it refers to a file in that current folder.

This example writes a text file first (so the file always exists), then reads it back.

```{python}
from pathlib import Path

path = Path("demo_text.txt")

path.write_text("first line\nsecond line\nthird line\n")

text = path.read_text()
print("file contents:\n" + text)

path.write_text("replacement line 1\nreplacement line 2\n")

updated_text = path.read_text()
print("updated file contents:\n" + updated_text)
```

Explanation:

1. `from pathlib import Path` imports the `Path` class from the `pathlib` module.
2. `path = Path("demo_text.txt")` creates a `Path` object representing a file named `demo_text.txt` in the current working directory.
3. `path.write_text("first line\nsecond line\nthird line\n")` writes the given string to the file. If the file does not exist, it is created. If it already exists, its contents are replaced.
4. `text = path.read_text()` reads the entire file and returns it as a single string.
5. `print("file contents:\n" + text)` prints the contents that were read so the result is visible.
6. `path.write_text("replacement line 1\nreplacement line 2\n")` writes new text to the same file, replacing the previous contents.
7. `updated_text = path.read_text()` reads the file again after the update.
8. `print("updated file contents:\n" + updated_text)` prints the updated contents so the change is visible.


## Summary of key points

* Names refer to objects; collection objects store references to other objects.
* `is` tests identity; `==` tests value equality.
* Rebinding and mutation produce different effects.
* Lists and dictionaries are mutable; tuples are immutable.
* Set types enforce uniqueness and require hashable elements.
* Shallow copies share nested objects; deep copies replicate nested objects.
* `pathlib.Path` provides a modern way to read and write text files.



